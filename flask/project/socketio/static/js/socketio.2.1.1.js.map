{
version: 3,
sources:
[
"webpack:///webpack/universalModuleDefinition",
"webpack:///socket.io.js",
"webpack:///webpack/bootstrap 3dcdaa84a447b9ebdc0b",
"webpack:///./lib/index.js",
"webpack:///./lib/url.js",
"webpack:///./~/parseuri/index.js",
"webpack:///./~/debug/src/browser.js",
"webpack:///./~/process/browser.js",
"webpack:///./~/debug/src/debug.js",
"webpack:///./~/ms/index.js",
"webpack:///./~/socket.io-parser/index.js",
"webpack:///./~/component-emitter/index.js",
"webpack:///./~/socket.io-parser/binary.js",
"webpack:///./~/isarray/index.js",
"webpack:///./~/socket.io-parser/is-buffer.js",
"webpack:///./lib/manager.js",
"webpack:///./~/engine.io-client/lib/index.js",
"webpack:///./~/engine.io-client/lib/socket.js",
"webpack:///./~/engine.io-client/lib/transports/index.js",
"webpack:///./~/engine.io-client/lib/xmlhttprequest.js",
"webpack:///./~/has-cors/index.js",
"webpack:///./~/engine.io-client/lib/transports/polling-xhr.js",
"webpack:///./~/engine.io-client/lib/transports/polling.js",
"webpack:///./~/engine.io-client/lib/transport.js",
"webpack:///./~/engine.io-parser/lib/browser.js",
"webpack:///./~/engine.io-parser/lib/keys.js",
"webpack:///./~/has-binary2/index.js",
"webpack:///./~/arraybuffer.slice/index.js",
"webpack:///./~/after/index.js",
"webpack:///./~/engine.io-parser/lib/utf8.js",
"webpack:///(webpack)/buildin/module.js",
"webpack:///./~/base64-arraybuffer/lib/base64-arraybuffer.js",
"webpack:///./~/blob/index.js",
"webpack:///./~/parseqs/index.js",
"webpack:///./~/component-inherit/index.js",
"webpack:///./~/yeast/index.js",
"webpack:///./~/engine.io-client/lib/transports/polling-jsonp.js",
"webpack:///./~/engine.io-client/lib/transports/websocket.js",
"webpack:///./~/indexof/index.js",
"webpack:///./lib/socket.js",
"webpack:///./~/to-array/index.js",
"webpack:///./lib/on.js",
"webpack:///./~/component-bind/index.js",
"webpack:///./~/backo2/index.js",
],
names:
[
"root",
"factory",
"exports",
"module",
"define",
"amd",
"this",
"modules",
"__webpack_require__",
"moduleId",
"installedModules",
"id",
"loaded",
"call",
"m",
"c",
"p",
"lookup",
"uri",
"opts",
"_typeof",
"undefined",
"io",
"parsed",
"url",
"source",
"path",
"sameNamespace",
"cache",
"nsps",
"newConnection",
"forceNew",
"multiplex",
"debug",
"Manager",
"query",
"socket",
"Symbol",
"iterator",
"obj",
"constructor",
"prototype",
"parser",
"managers",
"protocol",
"connect",
"Socket",
"global",
"loc",
"location",
"host",
"charAt",
"test",
"parseuri",
"port",
"ipv6",
"indexOf",
"href",
"re",
"parts",
"str",
"src",
"b",
"e",
"substring",
"replace",
"length",
"exec",
"i",
"authority",
"ipv6uri",
"process",
"useColors",
"window",
"type",
"navigator",
"userAgent",
"toLowerCase",
"match",
"document",
"documentElement",
"style",
"WebkitAppearance",
"console",
"firebug",
"exception",
"table",
"parseInt",
"RegExp",
"$1",
"formatArgs",
"args",
"namespace",
"humanize",
"diff",
"color",
"splice",
"index",
"lastC",
"log",
"Function",
"apply",
"arguments",
"save",
"namespaces",
"storage",
"removeItem",
"load",
"r",
"env",
"DEBUG",
"localstorage",
"localStorage",
"chrome",
"local",
"colors",
"formatters",
"j",
"v",
"JSON",
"stringify",
"err",
"message",
"enable",
"defaultSetTimout",
"Error",
"defaultClearTimeout",
"runTimeout",
"fun",
"cachedSetTimeout",
"setTimeout",
"runClearTimeout",
"marker",
"cachedClearTimeout",
"clearTimeout",
"cleanUpNextTick",
"draining",
"currentQueue",
"queue",
"concat",
"queueIndex",
"drainQueue",
"timeout",
"len",
"run",
"Item",
"array",
"noop",
"nextTick",
"Array",
"push",
"title",
"browser",
"argv",
"version",
"versions",
"on",
"addListener",
"once",
"off",
"removeListener",
"removeAllListeners",
"emit",
"prependListener",
"prependOnceListener",
"listeners",
"name",
"binding",
"cwd",
"chdir",
"dir",
"umask",
"selectColor",
"hash",
"charCodeAt",
"Math",
"abs",
"createDebug",
"enabled",
"self",
"curr",
"Date",
"ms",
"prevTime",
"prev",
"coerce",
"unshift",
"format",
"formatter",
"val",
"logFn",
"bind",
"destroy",
"init",
"instances",
"names",
"skips",
"split",
"substr",
"instance",
"disable",
"stack",
"parse",
"String",
"n",
"parseFloat",
"y",
"d",
"h",
"s",
"fmtShort",
"round",
"fmtLong",
"plural",
"floor",
"ceil",
"options",
"isNaN",
"Encoder",
"encodeAsString",
"BINARY_EVENT",
"BINARY_ACK",
"attachments",
"nsp",
"data",
"payload",
"tryStringify",
"ERROR_PACKET",
"encodeAsBinary",
"callback",
"writeEncoding",
"bloblessData",
"deconstruction",
"binary",
"deconstructPacket",
"pack",
"packet",
"buffers",
"removeBlobs",
"Decoder",
"reconstructor",
"decodeString",
"Number",
"types",
"error",
"buf",
"next",
"tryParse",
"isPayloadValid",
"ERROR",
"isArray",
"BinaryReconstructor",
"reconPack",
"msg",
"Emitter",
"isBuf",
"CONNECT",
"DISCONNECT",
"EVENT",
"ACK",
"encode",
"encoding",
"add",
"base64",
"takeBinaryData",
"finishedReconstruction",
"binData",
"reconstructPacket",
"mixin",
"key",
"addEventListener",
"event",
"fn",
"_callbacks",
"removeEventListener",
"callbacks",
"cb",
"slice",
"hasListeners",
"_deconstructPacket",
"placeholder",
"_placeholder",
"num",
"newData",
"_reconstructPacket",
"toString",
"Object",
"withNativeBlob",
"Blob",
"withNativeFile",
"File",
"packetData",
"_removeBlobs",
"curKey",
"containingObject",
"pendingBlobs",
"fileReader",
"FileReader",
"onload",
"result",
"readAsArrayBuffer",
"arr",
"withNativeBuffer",
"Buffer",
"isBuffer",
"withNativeArrayBuffer",
"ArrayBuffer",
"isView",
"buffer",
"subs",
"reconnection",
"reconnectionAttempts",
"Infinity",
"reconnectionDelay",
"reconnectionDelayMax",
"randomizationFactor",
"backoff",
"Backoff",
"min",
"max",
"jitter",
"readyState",
"connecting",
"lastPing",
"packetBuffer",
"_parser",
"encoder",
"decoder",
"autoConnect",
"open",
"eio",
"has",
"hasOwnProperty",
"emitAll",
"updateSocketIds",
"generateId",
"engine",
"_reconnection",
"_reconnectionAttempts",
"_reconnectionDelay",
"setMin",
"_randomizationFactor",
"setJitter",
"_reconnectionDelayMax",
"setMax",
"_timeout",
"maybeReconnectOnOpen",
"reconnecting",
"attempts",
"reconnect",
"skipReconnect",
"openSub",
"onopen",
"errorSub",
"cleanup",
"timer",
"close",
"onping",
"onpong",
"ondata",
"ondecoded",
"onerror",
"onConnecting",
"encodedPackets",
"write",
"processPacketQueue",
"shift",
"subsLength",
"sub",
"disconnect",
"reset",
"onclose",
"reason",
"delay",
"duration",
"onreconnect",
"attempt",
"hostname",
"secure",
"agent",
"parseqs",
"decode",
"upgrade",
"forceJSONP",
"jsonp",
"forceBase64",
"enablesXDR",
"timestampParam",
"timestampRequests",
"transports",
"transportOptions",
"writeBuffer",
"prevBufferLen",
"policyPort",
"rememberUpgrade",
"binaryType",
"onlyBinaryUpgrades",
"perMessageDeflate",
"threshold",
"pfx",
"passphrase",
"cert",
"ca",
"ciphers",
"rejectUnauthorized",
"forceNode",
"freeGlobal",
"extraHeaders",
"keys",
"localAddress",
"upgrades",
"pingInterval",
"pingTimeout",
"pingIntervalTimer",
"pingTimeoutTimer",
"clone",
"o",
"priorWebsocketSuccess",
"Transport",
"createTransport",
"EIO",
"transport",
"sid",
"requestTimeout",
"protocols",
"setTransport",
"onDrain",
"onPacket",
"onError",
"onClose",
"probe",
"onTransportOpen",
"upgradeLosesBinary",
"supportsBinary",
"failed",
"send",
"upgrading",
"pause",
"flush",
"freezeTransport",
"onTransportClose",
"onupgrade",
"to",
"onOpen",
"l",
"onHandshake",
"setPing",
"code",
"filterUpgrades",
"onHeartbeat",
"ping",
"sendPacket",
"writable",
"compress",
"cleanupAndClose",
"waitForUpgrade",
"desc",
"filteredUpgrades",
"polling",
"xhr",
"xd",
"xs",
"isSSL",
"xdomain",
"xscheme",
"XMLHttpRequest",
"XHR",
"JSONP",
"websocket",
"hasCORS",
"XDomainRequest",
"join",
"empty",
"Polling",
"Request",
"method",
"async",
"isBinary",
"create",
"unloadHandler",
"requests",
"abort",
"inherit",
"request",
"doWrite",
"req",
"sendXhr",
"doPoll",
"onData",
"pollXhr",
"setDisableHeaderCheck",
"setRequestHeader",
"withCredentials",
"hasXDR",
"onLoad",
"responseText",
"onreadystatechange",
"contentType",
"getResponseHeader",
"responseType",
"status",
"requestsCount",
"onSuccess",
"fromError",
"response",
"attachEvent",
"hasXHR2",
"yeast",
"doOpen",
"poll",
"onPause",
"total",
"decodePayload",
"doClose",
"packets",
"callbackfn",
"encodePayload",
"schema",
"b64",
"description",
"decodePacket",
"encodeBase64Object",
"encodeArrayBuffer",
"encodeBase64Packet",
"contentArray",
"Uint8Array",
"resultBuffer",
"byteLength",
"encodeBlobAsArrayBuffer",
"fr",
"encodePacket",
"encodeBlob",
"dontSendBlobs",
"blob",
"tryDecode",
"utf8",
"strict",
"map",
"ary",
"each",
"done",
"after",
"eachWithIndex",
"el",
"base64encoder",
"hasBinary",
"sliceBuffer",
"isAndroid",
"isPhantomJS",
"pong",
"packetslist",
"utf8encode",
"encoded",
"readAsDataURL",
"b64data",
"fromCharCode",
"typed",
"basic",
"btoa",
"utf8decode",
"decodeBase64Packet",
"asArray",
"rest",
"setLengthHeader",
"encodeOne",
"doneCallback",
"encodePayloadAsBlob",
"encodePayloadAsArrayBuffer",
"results",
"decodePayloadAsBinary",
"chr",
"ret",
"totalLength",
"reduce",
"acc",
"resultArray",
"bufferIndex",
"forEach",
"isString",
"ab",
"view",
"lenStr",
"binaryIdentifier",
"size",
"lengthAry",
"bufferTail",
"tailArray",
"msgLength",
"toJSON",
"arraybuffer",
"start",
"end",
"bytes",
"abv",
"ii",
"count",
"err_cb",
"proxy",
"bail",
"__WEBPACK_AMD_DEFINE_RESULT__",
"ucs2decode",
"string",
"value",
"extra",
"output",
"counter",
"ucs2encode",
"stringFromCharCode",
"checkScalarValue",
"codePoint",
"toUpperCase",
"createByte",
"encodeCodePoint",
"symbol",
"codePoints",
"byteString",
"readContinuationByte",
"byteIndex",
"byteCount",
"continuationByte",
"byteArray",
"decodeSymbol",
"byte1",
"byte2",
"byte3",
"byte4",
"tmp",
"freeExports",
"webpackPolyfill",
"deprecate",
"paths",
"children",
"chars",
"encoded1",
"encoded2",
"encoded3",
"encoded4",
"bufferLength",
"mapArrayBufferViews",
"chunk",
"copy",
"set",
"byteOffset",
"BlobBuilderConstructor",
"bb",
"BlobBuilder",
"append",
"getBlob",
"BlobConstructor",
"WebKitBlobBuilder",
"MSBlobBuilder",
"MozBlobBuilder",
"blobSupported",
"a",
"blobSupportsArrayBufferView",
"blobBuilderSupported",
"encodeURIComponent",
"qs",
"qry",
"pairs",
"pair",
"decodeURIComponent",
"alphabet",
"decoded",
"now",
"seed",
"JSONPPolling",
"___eio",
"script",
"rNewline",
"rEscapedNewline",
"parentNode",
"removeChild",
"form",
"iframe",
"createElement",
"insertAt",
"getElementsByTagName",
"insertBefore",
"head",
"body",
"appendChild",
"isUAgecko",
"complete",
"initIframe",
"html",
"iframeId",
"area",
"className",
"position",
"top",
"left",
"target",
"setAttribute",
"action",
"submit",
"WS",
"usingBrowserWebSocket",
"BrowserWebSocket",
"WebSocket",
"NodeWebSocket",
"MozWebSocket",
"check",
"headers",
"ws",
"supports",
"addEventListeners",
"onmessage",
"ev",
"json",
"ids",
"acks",
"receiveBuffer",
"sendBuffer",
"connected",
"disconnected",
"flags",
"toArray",
"hasBin",
"events",
"connect_error",
"connect_timeout",
"reconnect_attempt",
"reconnect_failed",
"reconnect_error",
"subEvents",
"pop",
"onpacket",
"rootNamespaceError",
"onconnect",
"onevent",
"onack",
"ondisconnect",
"ack",
"sent",
"emitBuffered",
"list",
"factor",
"pow",
"rand",
"random",
"deviation",
],
mappings: "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",
file: "socket.io.js",
sourcesContent:
[
"(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(this, function() {
return


// WEBPACK FOOTER //
// webpack/universalModuleDefinition",
"(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["io"] = factory();
	else
		root["io"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var url = __webpack_require__(1);
	var parser = __webpack_require__(7);
	var Manager = __webpack_require__(12);
	var debug = __webpack_require__(3)('socket.io-client');

	/**
	 * Module exports.
	 */

	module.exports = exports = lookup;

	/**
	 * Managers cache.
	 */

	var cache = exports.managers = {};

	/**
	 * Looks up an existing `Manager` for multiplexing.
	 * If the user summons:
	 *
	 *   `io('http://localhost/a');`
	 *   `io('http://localhost/b');`
	 *
	 * We reuse the existing instance based on same scheme/port/host,
	 * and we initialize sockets for each namespace.
	 *
	 * @api public
	 */

	function lookup(uri, opts) {
	  if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
	    opts = uri;
	    uri = undefined;
	  }

	  opts = opts || {};

	  var parsed = url(uri);
	  var source = parsed.source;
	  var id = parsed.id;
	  var path = parsed.path;
	  var sameNamespace = cache[id] && path in cache[id].nsps;
	  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

	  var io;

	  if (newConnection) {
	    debug('ignoring socket cache for %s', source);
	    io = Manager(source, opts);
	  } else {
	    if (!cache[id]) {
	      debug('new io instance for %s', source);
	      cache[id] = Manager(source, opts);
	    }
	    io = cache[id];
	  }
	  if (parsed.query && !opts.query) {
	    opts.query = parsed.query;
	  }
	  return io.socket(parsed.path, opts);
	}

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = parser.protocol;

	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @api public
	 */

	exports.connect = lookup;

	/**
	 * Expose constructors for standalone build.
	 *
	 * @api public
	 */

	exports.Manager = __webpack_require__(12);
	exports.Socket = __webpack_require__(37);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/**
	 * Module dependencies.
	 */

	var parseuri = __webpack_require__(2);
	var debug = __webpack_require__(3)('socket.io-client:url');

	/**
	 * Module exports.
	 */

	module.exports = url;

	/**
	 * URL parser.
	 *
	 * @param {String} url
	 * @param {Object} An object meant to mimic window.location.
	 *                 Defaults to window.location.
	 * @api public
	 */

	function url(uri, loc) {
	  var obj = uri;

	  // default to window.location
	  loc = loc || global.location;
	  if (null == uri) uri = loc.protocol + '//' + loc.host;

	  // relative path support
	  if ('string' === typeof uri) {
	    if ('/' === uri.charAt(0)) {
	      if ('/' === uri.charAt(1)) {
	        uri = loc.protocol + uri;
	      } else {
	        uri = loc.host + uri;
	      }
	    }

	    if (!/^(https?|wss?):\/\//.test(uri)) {
	      debug('protocol-less url %s', uri);
	      if ('undefined' !== typeof loc) {
	        uri = loc.protocol + '//' + uri;
	      } else {
	        uri = 'https://' + uri;
	      }
	    }

	    // parse
	    debug('parse %s', uri);
	    obj = parseuri(uri);
	  }

	  // make sure we treat `localhost:80` and `localhost` equally
	  if (!obj.port) {
	    if (/^(http|ws)$/.test(obj.protocol)) {
	      obj.port = '80';
	    } else if (/^(http|ws)s$/.test(obj.protocol)) {
	      obj.port = '443';
	    }
	  }

	  obj.path = obj.path || '/';

	  var ipv6 = obj.host.indexOf(':') !== -1;
	  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

	  // define unique id
	  obj.id = obj.protocol + '://' + host + ':' + obj.port;
	  // define href
	  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);

	  return obj;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */

	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];

	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');

	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }

	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;

	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }

	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }

	    return uri;
	};


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(5);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = [
	  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
	  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
	  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
	  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
	  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
	  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
	  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
	  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
	  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
	  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
	  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
	];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }

	  // Internet Explorer and Edge do not support colors.
	  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	    return false;
	  }

	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};


	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs(args) {
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);

	  if (!useColors) return;

	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}

	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }

	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {


	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(6);

	/**
	 * Active `debug` instances.
	 */
	exports.instances = [];

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */

	exports.formatters = {};

	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */

	function selectColor(namespace) {
	  var hash = 0, i;

	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }

	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function createDebug(namespace) {

	  var prevTime;

	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;

	    var self = debug;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);

	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }

	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	  debug.destroy = destroy;

	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }

	  exports.instances.push(debug);

	  return debug;
	}

	function destroy () {
	  var index = exports.instances.indexOf(this);
	  if (index !== -1) {
	    exports.instances.splice(index, 1);
	    return true;
	  } else {
	    return false;
	  }
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  exports.names = [];
	  exports.skips = [];

	  var i;
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;

	  for (i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }

	  for (i = 0; i < exports.instances.length; i++) {
	    var instance = exports.instances[i];
	    instance.enabled = exports.enabled(instance.namespace);
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  if (name[name.length - 1] === '*') {
	    return true;
	  }
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {


	/**
	 * Module dependencies.
	 */

	var debug = __webpack_require__(3)('socket.io-parser');
	var Emitter = __webpack_require__(8);
	var binary = __webpack_require__(9);
	var isArray = __webpack_require__(10);
	var isBuf = __webpack_require__(11);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	exports.protocol = 4;

	/**
	 * Packet types.
	 *
	 * @api public
	 */

	exports.types = [
	  'CONNECT',
	  'DISCONNECT',
	  'EVENT',
	  'ACK',
	  'ERROR',
	  'BINARY_EVENT',
	  'BINARY_ACK'
	];

	/**
	 * Packet type `connect`.
	 *
	 * @api public
	 */

	exports.CONNECT = 0;

	/**
	 * Packet type `disconnect`.
	 *
	 * @api public
	 */

	exports.DISCONNECT = 1;

	/**
	 * Packet type `event`.
	 *
	 * @api public
	 */

	exports.EVENT = 2;

	/**
	 * Packet type `ack`.
	 *
	 * @api public
	 */

	exports.ACK = 3;

	/**
	 * Packet type `error`.
	 *
	 * @api public
	 */

	exports.ERROR = 4;

	/**
	 * Packet type 'binary event'
	 *
	 * @api public
	 */

	exports.BINARY_EVENT = 5;

	/**
	 * Packet type `binary ack`. For acks with binary arguments.
	 *
	 * @api public
	 */

	exports.BINARY_ACK = 6;

	/**
	 * Encoder constructor.
	 *
	 * @api public
	 */

	exports.Encoder = Encoder;

	/**
	 * Decoder constructor.
	 *
	 * @api public
	 */

	exports.Decoder = Decoder;

	/**
	 * A socket.io Encoder instance
	 *
	 * @api public
	 */

	function Encoder() {}

	var ERROR_PACKET = exports.ERROR + '"encode error"';

	/**
	 * Encode a packet as a single string if non-binary, or as a
	 * buffer sequence, depending on packet type.
	 *
	 * @param {Object} obj - packet object
	 * @param {Function} callback - function to handle encodings (likely engine.write)
	 * @return Calls callback with Array of encodings
	 * @api public
	 */

	Encoder.prototype.encode = function(obj, callback){
	  debug('encoding packet %j', obj);

	  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
	    encodeAsBinary(obj, callback);
	  } else {
	    var encoding = encodeAsString(obj);
	    callback([encoding]);
	  }
	};

	/**
	 * Encode packet as string.
	 *
	 * @param {Object} packet
	 * @return {String} encoded
	 * @api private
	 */

	function encodeAsString(obj) {

	  // first is type
	  var str = '' + obj.type;

	  // attachments if we have them
	  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
	    str += obj.attachments + '-';
	  }

	  // if we have a namespace other than `/`
	  // we append it followed by a comma `,`
	  if (obj.nsp && '/' !== obj.nsp) {
	    str += obj.nsp + ',';
	  }

	  // immediately followed by the id
	  if (null != obj.id) {
	    str += obj.id;
	  }

	  // json data
	  if (null != obj.data) {
	    var payload = tryStringify(obj.data);
	    if (payload !== false) {
	      str += payload;
	    } else {
	      return ERROR_PACKET;
	    }
	  }

	  debug('encoded %j as %s', obj, str);
	  return str;
	}

	function tryStringify(str) {
	  try {
	    return JSON.stringify(str);
	  } catch(e){
	    return false;
	  }
	}

	/**
	 * Encode packet as 'buffer sequence' by removing blobs, and
	 * deconstructing packet into object with placeholders and
	 * a list of buffers.
	 *
	 * @param {Object} packet
	 * @return {Buffer} encoded
	 * @api private
	 */

	function encodeAsBinary(obj, callback) {

	  function writeEncoding(bloblessData) {
	    var deconstruction = binary.deconstructPacket(bloblessData);
	    var pack = encodeAsString(deconstruction.packet);
	    var buffers = deconstruction.buffers;

	    buffers.unshift(pack); // add packet info to beginning of data list
	    callback(buffers); // write all the buffers
	  }

	  binary.removeBlobs(obj, writeEncoding);
	}

	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 * @api public
	 */

	function Decoder() {
	  this.reconstructor = null;
	}

	/**
	 * Mix in `Emitter` with Decoder.
	 */

	Emitter(Decoder.prototype);

	/**
	 * Decodes an ecoded packet string into packet JSON.
	 *
	 * @param {String} obj - encoded packet
	 * @return {Object} packet
	 * @api public
	 */

	Decoder.prototype.add = function(obj) {
	  var packet;
	  if (typeof obj === 'string') {
	    packet = decodeString(obj);
	    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
	      this.reconstructor = new BinaryReconstructor(packet);

	      // no attachments, labeled binary but no binary data to follow
	      if (this.reconstructor.reconPack.attachments === 0) {
	        this.emit('decoded', packet);
	      }
	    } else { // non-binary full packet
	      this.emit('decoded', packet);
	    }
	  }
	  else if (isBuf(obj) || obj.base64) { // raw binary data
	    if (!this.reconstructor) {
	      throw new Error('got binary data when not reconstructing a packet');
	    } else {
	      packet = this.reconstructor.takeBinaryData(obj);
	      if (packet) { // received final buffer
	        this.reconstructor = null;
	        this.emit('decoded', packet);
	      }
	    }
	  }
	  else {
	    throw new Error('Unknown type: ' + obj);
	  }
	};

	/**
	 * Decode a packet String (JSON data)
	 *
	 * @param {String} str
	 * @return {Object} packet
	 * @api private
	 */

	function decodeString(str) {
	  var i = 0;
	  // look up type
	  var p = {
	    type: Number(str.charAt(0))
	  };

	  if (null == exports.types[p.type]) {
	    return error('unknown packet type ' + p.type);
	  }

	  // look up attachments if type binary
	  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
	    var buf = '';
	    while (str.charAt(++i) !== '-') {
	      buf += str.charAt(i);
	      if (i == str.length) break;
	    }
	    if (buf != Number(buf) || str.charAt(i) !== '-') {
	      throw new Error('Illegal attachments');
	    }
	    p.attachments = Number(buf);
	  }

	  // look up namespace (if any)
	  if ('/' === str.charAt(i + 1)) {
	    p.nsp = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (',' === c) break;
	      p.nsp += c;
	      if (i === str.length) break;
	    }
	  } else {
	    p.nsp = '/';
	  }

	  // look up id
	  var next = str.charAt(i + 1);
	  if ('' !== next && Number(next) == next) {
	    p.id = '';
	    while (++i) {
	      var c = str.charAt(i);
	      if (null == c || Number(c) != c) {
	        --i;
	        break;
	      }
	      p.id += str.charAt(i);
	      if (i === str.length) break;
	    }
	    p.id = Number(p.id);
	  }

	  // look up json data
	  if (str.charAt(++i)) {
	    var payload = tryParse(str.substr(i));
	    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
	    if (isPayloadValid) {
	      p.data = payload;
	    } else {
	      return error('invalid payload');
	    }
	  }

	  debug('decoded %s as %j', str, p);
	  return p;
	}

	function tryParse(str) {
	  try {
	    return JSON.parse(str);
	  } catch(e){
	    return false;
	  }
	}

	/**
	 * Deallocates a parser's resources
	 *
	 * @api public
	 */

	Decoder.prototype.destroy = function() {
	  if (this.reconstructor) {
	    this.reconstructor.finishedReconstruction();
	  }
	};

	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 * @api private
	 */

	function BinaryReconstructor(packet) {
	  this.reconPack = packet;
	  this.buffers = [];
	}

	/**
	 * Method to be called when binary data received from connection
	 * after a BINARY_EVENT packet.
	 *
	 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	 * @return {null | Object} returns null if more binary data is expected or
	 *   a reconstructed packet object if all buffers have been received.
	 * @api private
	 */

	BinaryReconstructor.prototype.takeBinaryData = function(binData) {
	  this.buffers.push(binData);
	  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
	    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
	    this.finishedReconstruction();
	    return packet;
	  }
	  return null;
	};

	/**
	 * Cleans up binary packet reconstruction variables.
	 *
	 * @api private
	 */

	BinaryReconstructor.prototype.finishedReconstruction = function() {
	  this.reconPack = null;
	  this.buffers = [];
	};

	function error(msg) {
	  return {
	    type: exports.ERROR,
	    data: 'parser error: ' + msg
	  };
	}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {


	/**
	 * Expose `Emitter`.
	 */

	if (true) {
	  module.exports = Emitter;
	}

	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */

	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};

	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */

	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}

	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};

	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }

	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};

	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */

	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};

	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }

	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;

	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }

	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};

	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */

	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];

	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }

	  return this;
	};

	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */

	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};

	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */

	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

	/**
	 * Module requirements
	 */

	var isArray = __webpack_require__(10);
	var isBuf = __webpack_require__(11);
	var toString = Object.prototype.toString;
	var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
	var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

	/**
	 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
	 * Anything with blobs or files should be fed through removeBlobs before coming
	 * here.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @api public
	 */

	exports.deconstructPacket = function(packet) {
	  var buffers = [];
	  var packetData = packet.data;
	  var pack = packet;
	  pack.data = _deconstructPacket(packetData, buffers);
	  pack.attachments = buffers.length; // number of binary 'attachments'
	  return {packet: pack, buffers: buffers};
	};

	function _deconstructPacket(data, buffers) {
	  if (!data) return data;

	  if (isBuf(data)) {
	    var placeholder = { _placeholder: true, num: buffers.length };
	    buffers.push(data);
	    return placeholder;
	  } else if (isArray(data)) {
	    var newData = new Array(data.length);
	    for (var i = 0; i < data.length; i++) {
	      newData[i] = _deconstructPacket(data[i], buffers);
	    }
	    return newData;
	  } else if (typeof data === 'object' && !(data instanceof Date)) {
	    var newData = {};
	    for (var key in data) {
	      newData[key] = _deconstructPacket(data[key], buffers);
	    }
	    return newData;
	  }
	  return data;
	}

	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @api public
	 */

	exports.reconstructPacket = function(packet, buffers) {
	  packet.data = _reconstructPacket(packet.data, buffers);
	  packet.attachments = undefined; // no longer useful
	  return packet;
	};

	function _reconstructPacket(data, buffers) {
	  if (!data) return data;

	  if (data && data._placeholder) {
	    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
	  } else if (isArray(data)) {
	    for (var i = 0; i < data.length; i++) {
	      data[i] = _reconstructPacket(data[i], buffers);
	    }
	  } else if (typeof data === 'object') {
	    for (var key in data) {
	      data[key] = _reconstructPacket(data[key], buffers);
	    }
	  }

	  return data;
	}

	/**
	 * Asynchronously removes Blobs or Files from data via
	 * FileReader's readAsArrayBuffer method. Used before encoding
	 * data as msgpack. Calls callback with the blobless data.
	 *
	 * @param {Object} data
	 * @param {Function} callback
	 * @api private
	 */

	exports.removeBlobs = function(data, callback) {
	  function _removeBlobs(obj, curKey, containingObject) {
	    if (!obj) return obj;

	    // convert any blob
	    if ((withNativeBlob && obj instanceof Blob) ||
	        (withNativeFile && obj instanceof File)) {
	      pendingBlobs++;

	      // async filereader
	      var fileReader = new FileReader();
	      fileReader.onload = function() { // this.result == arraybuffer
	        if (containingObject) {
	          containingObject[curKey] = this.result;
	        }
	        else {
	          bloblessData = this.result;
	        }

	        // if nothing pending its callback time
	        if(! --pendingBlobs) {
	          callback(bloblessData);
	        }
	      };

	      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
	    } else if (isArray(obj)) { // handle array
	      for (var i = 0; i < obj.length; i++) {
	        _removeBlobs(obj[i], i, obj);
	      }
	    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
	      for (var key in obj) {
	        _removeBlobs(obj[key], key, obj);
	      }
	    }
	  }

	  var pendingBlobs = 0;
	  var bloblessData = data;
	  _removeBlobs(bloblessData);
	  if (!pendingBlobs) {
	    callback(bloblessData);
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	module.exports = isBuf;

	var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
	var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';

	var isView = (function () {
	  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
	    return global.ArrayBuffer.isView;
	  } else {
	    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
	  }
	})();

	/**
	 * Returns true if obj is a buffer or an arraybuffer.
	 *
	 * @api private
	 */

	function isBuf(obj) {
	  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
	          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var eio = __webpack_require__(13);
	var Socket = __webpack_require__(37);
	var Emitter = __webpack_require__(8);
	var parser = __webpack_require__(7);
	var on = __webpack_require__(39);
	var bind = __webpack_require__(40);
	var debug = __webpack_require__(3)('socket.io-client:manager');
	var indexOf = __webpack_require__(36);
	var Backoff = __webpack_require__(41);

	/**
	 * IE6+ hasOwnProperty
	 */

	var has = Object.prototype.hasOwnProperty;

	/**
	 * Module exports
	 */

	module.exports = Manager;

	/**
	 * `Manager` constructor.
	 *
	 * @param {String} engine instance or engine uri/opts
	 * @param {Object} options
	 * @api public
	 */

	function Manager(uri, opts) {
	  if (!(this instanceof Manager)) return new Manager(uri, opts);
	  if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
	    opts = uri;
	    uri = undefined;
	  }
	  opts = opts || {};

	  opts.path = opts.path || '/socket.io';
	  this.nsps = {};
	  this.subs = [];
	  this.opts = opts;
	  this.reconnection(opts.reconnection !== false);
	  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	  this.reconnectionDelay(opts.reconnectionDelay || 1000);
	  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	  this.randomizationFactor(opts.randomizationFactor || 0.5);
	  this.backoff = new Backoff({
	    min: this.reconnectionDelay(),
	    max: this.reconnectionDelayMax(),
	    jitter: this.randomizationFactor()
	  });
	  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	  this.readyState = 'closed';
	  this.uri = uri;
	  this.connecting = [];
	  this.lastPing = null;
	  this.encoding = false;
	  this.packetBuffer = [];
	  var _parser = opts.parser || parser;
	  this.encoder = new _parser.Encoder();
	  this.decoder = new _parser.Decoder();
	  this.autoConnect = opts.autoConnect !== false;
	  if (this.autoConnect) this.open();
	}

	/**
	 * Propagate given event to sockets and emit on `this`
	 *
	 * @api private
	 */

	Manager.prototype.emitAll = function () {
	  this.emit.apply(this, arguments);
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
	    }
	  }
	};

	/**
	 * Update `socket.id` of all sockets
	 *
	 * @api private
	 */

	Manager.prototype.updateSocketIds = function () {
	  for (var nsp in this.nsps) {
	    if (has.call(this.nsps, nsp)) {
	      this.nsps[nsp].id = this.generateId(nsp);
	    }
	  }
	};

	/**
	 * generate `socket.id` for the given `nsp`
	 *
	 * @param {String} nsp
	 * @return {String}
	 * @api private
	 */

	Manager.prototype.generateId = function (nsp) {
	  return (nsp === '/' ? '' : nsp + '#') + this.engine.id;
	};

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Manager.prototype);

	/**
	 * Sets the `reconnection` config.
	 *
	 * @param {Boolean} true/false if it should automatically reconnect
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnection = function (v) {
	  if (!arguments.length) return this._reconnection;
	  this._reconnection = !!v;
	  return this;
	};

	/**
	 * Sets the reconnection attempts config.
	 *
	 * @param {Number} max reconnection attempts before giving up
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionAttempts = function (v) {
	  if (!arguments.length) return this._reconnectionAttempts;
	  this._reconnectionAttempts = v;
	  return this;
	};

	/**
	 * Sets the delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelay = function (v) {
	  if (!arguments.length) return this._reconnectionDelay;
	  this._reconnectionDelay = v;
	  this.backoff && this.backoff.setMin(v);
	  return this;
	};

	Manager.prototype.randomizationFactor = function (v) {
	  if (!arguments.length) return this._randomizationFactor;
	  this._randomizationFactor = v;
	  this.backoff && this.backoff.setJitter(v);
	  return this;
	};

	/**
	 * Sets the maximum delay between reconnections.
	 *
	 * @param {Number} delay
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.reconnectionDelayMax = function (v) {
	  if (!arguments.length) return this._reconnectionDelayMax;
	  this._reconnectionDelayMax = v;
	  this.backoff && this.backoff.setMax(v);
	  return this;
	};

	/**
	 * Sets the connection timeout. `false` to disable
	 *
	 * @return {Manager} self or value
	 * @api public
	 */

	Manager.prototype.timeout = function (v) {
	  if (!arguments.length) return this._timeout;
	  this._timeout = v;
	  return this;
	};

	/**
	 * Starts trying to reconnect if reconnection is enabled and we have not
	 * started reconnecting yet
	 *
	 * @api private
	 */

	Manager.prototype.maybeReconnectOnOpen = function () {
	  // Only try to reconnect if it's the first time we're connecting
	  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
	    // keeps reconnection from firing twice for the same reconnection loop
	    this.reconnect();
	  }
	};

	/**
	 * Sets the current transport `socket`.
	 *
	 * @param {Function} optional, callback
	 * @return {Manager} self
	 * @api public
	 */

	Manager.prototype.open = Manager.prototype.connect = function (fn, opts) {
	  debug('readyState %s', this.readyState);
	  if (~this.readyState.indexOf('open')) return this;

	  debug('opening %s', this.uri);
	  this.engine = eio(this.uri, this.opts);
	  var socket = this.engine;
	  var self = this;
	  this.readyState = 'opening';
	  this.skipReconnect = false;

	  // emit `open`
	  var openSub = on(socket, 'open', function () {
	    self.onopen();
	    fn && fn();
	  });

	  // emit `connect_error`
	  var errorSub = on(socket, 'error', function (data) {
	    debug('connect_error');
	    self.cleanup();
	    self.readyState = 'closed';
	    self.emitAll('connect_error', data);
	    if (fn) {
	      var err = new Error('Connection error');
	      err.data = data;
	      fn(err);
	    } else {
	      // Only do this if there is no fn to handle the error
	      self.maybeReconnectOnOpen();
	    }
	  });

	  // emit `connect_timeout`
	  if (false !== this._timeout) {
	    var timeout = this._timeout;
	    debug('connect attempt will timeout after %d', timeout);

	    // set timer
	    var timer = setTimeout(function () {
	      debug('connect attempt timed out after %d', timeout);
	      openSub.destroy();
	      socket.close();
	      socket.emit('error', 'timeout');
	      self.emitAll('connect_timeout', timeout);
	    }, timeout);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }

	  this.subs.push(openSub);
	  this.subs.push(errorSub);

	  return this;
	};

	/**
	 * Called upon transport open.
	 *
	 * @api private
	 */

	Manager.prototype.onopen = function () {
	  debug('open');

	  // clear old subs
	  this.cleanup();

	  // mark as open
	  this.readyState = 'open';
	  this.emit('open');

	  // add new subs
	  var socket = this.engine;
	  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
	  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
	  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
	  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
	  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
	  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
	};

	/**
	 * Called upon a ping.
	 *
	 * @api private
	 */

	Manager.prototype.onping = function () {
	  this.lastPing = new Date();
	  this.emitAll('ping');
	};

	/**
	 * Called upon a packet.
	 *
	 * @api private
	 */

	Manager.prototype.onpong = function () {
	  this.emitAll('pong', new Date() - this.lastPing);
	};

	/**
	 * Called with data.
	 *
	 * @api private
	 */

	Manager.prototype.ondata = function (data) {
	  this.decoder.add(data);
	};

	/**
	 * Called when parser fully decodes a packet.
	 *
	 * @api private
	 */

	Manager.prototype.ondecoded = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon socket error.
	 *
	 * @api private
	 */

	Manager.prototype.onerror = function (err) {
	  debug('error', err);
	  this.emitAll('error', err);
	};

	/**
	 * Creates a new socket for the given `nsp`.
	 *
	 * @return {Socket}
	 * @api public
	 */

	Manager.prototype.socket = function (nsp, opts) {
	  var socket = this.nsps[nsp];
	  if (!socket) {
	    socket = new Socket(this, nsp, opts);
	    this.nsps[nsp] = socket;
	    var self = this;
	    socket.on('connecting', onConnecting);
	    socket.on('connect', function () {
	      socket.id = self.generateId(nsp);
	    });

	    if (this.autoConnect) {
	      // manually call here since connecting event is fired before listening
	      onConnecting();
	    }
	  }

	  function onConnecting() {
	    if (!~indexOf(self.connecting, socket)) {
	      self.connecting.push(socket);
	    }
	  }

	  return socket;
	};

	/**
	 * Called upon a socket close.
	 *
	 * @param {Socket} socket
	 */

	Manager.prototype.destroy = function (socket) {
	  var index = indexOf(this.connecting, socket);
	  if (~index) this.connecting.splice(index, 1);
	  if (this.connecting.length) return;

	  this.close();
	};

	/**
	 * Writes a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Manager.prototype.packet = function (packet) {
	  debug('writing packet %j', packet);
	  var self = this;
	  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

	  if (!self.encoding) {
	    // encode, then write to engine with result
	    self.encoding = true;
	    this.encoder.encode(packet, function (encodedPackets) {
	      for (var i = 0; i < encodedPackets.length; i++) {
	        self.engine.write(encodedPackets[i], packet.options);
	      }
	      self.encoding = false;
	      self.processPacketQueue();
	    });
	  } else {
	    // add packet to the queue
	    self.packetBuffer.push(packet);
	  }
	};

	/**
	 * If packet buffer is non-empty, begins encoding the
	 * next packet in line.
	 *
	 * @api private
	 */

	Manager.prototype.processPacketQueue = function () {
	  if (this.packetBuffer.length > 0 && !this.encoding) {
	    var pack = this.packetBuffer.shift();
	    this.packet(pack);
	  }
	};

	/**
	 * Clean up transport subscriptions and packet buffer.
	 *
	 * @api private
	 */

	Manager.prototype.cleanup = function () {
	  debug('cleanup');

	  var subsLength = this.subs.length;
	  for (var i = 0; i < subsLength; i++) {
	    var sub = this.subs.shift();
	    sub.destroy();
	  }

	  this.packetBuffer = [];
	  this.encoding = false;
	  this.lastPing = null;

	  this.decoder.destroy();
	};

	/**
	 * Close the current socket.
	 *
	 * @api private
	 */

	Manager.prototype.close = Manager.prototype.disconnect = function () {
	  debug('disconnect');
	  this.skipReconnect = true;
	  this.reconnecting = false;
	  if ('opening' === this.readyState) {
	    // `onclose` will not fire because
	    // an open event never happened
	    this.cleanup();
	  }
	  this.backoff.reset();
	  this.readyState = 'closed';
	  if (this.engine) this.engine.close();
	};

	/**
	 * Called upon engine close.
	 *
	 * @api private
	 */

	Manager.prototype.onclose = function (reason) {
	  debug('onclose');

	  this.cleanup();
	  this.backoff.reset();
	  this.readyState = 'closed';
	  this.emit('close', reason);

	  if (this._reconnection && !this.skipReconnect) {
	    this.reconnect();
	  }
	};

	/**
	 * Attempt a reconnection.
	 *
	 * @api private
	 */

	Manager.prototype.reconnect = function () {
	  if (this.reconnecting || this.skipReconnect) return this;

	  var self = this;

	  if (this.backoff.attempts >= this._reconnectionAttempts) {
	    debug('reconnect failed');
	    this.backoff.reset();
	    this.emitAll('reconnect_failed');
	    this.reconnecting = false;
	  } else {
	    var delay = this.backoff.duration();
	    debug('will wait %dms before reconnect attempt', delay);

	    this.reconnecting = true;
	    var timer = setTimeout(function () {
	      if (self.skipReconnect) return;

	      debug('attempting reconnect');
	      self.emitAll('reconnect_attempt', self.backoff.attempts);
	      self.emitAll('reconnecting', self.backoff.attempts);

	      // check again for the case socket closed in above events
	      if (self.skipReconnect) return;

	      self.open(function (err) {
	        if (err) {
	          debug('reconnect attempt error');
	          self.reconnecting = false;
	          self.reconnect();
	          self.emitAll('reconnect_error', err.data);
	        } else {
	          debug('reconnect success');
	          self.onreconnect();
	        }
	      });
	    }, delay);

	    this.subs.push({
	      destroy: function destroy() {
	        clearTimeout(timer);
	      }
	    });
	  }
	};

	/**
	 * Called upon successful reconnect.
	 *
	 * @api private
	 */

	Manager.prototype.onreconnect = function () {
	  var attempt = this.backoff.attempts;
	  this.reconnecting = false;
	  this.backoff.reset();
	  this.updateSocketIds();
	  this.emitAll('reconnect', attempt);
	};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {


	module.exports = __webpack_require__(14);

	/**
	 * Exports parser
	 *
	 * @api public
	 *
	 */
	module.exports.parser = __webpack_require__(21);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var transports = __webpack_require__(15);
	var Emitter = __webpack_require__(8);
	var debug = __webpack_require__(3)('engine.io-client:socket');
	var index = __webpack_require__(36);
	var parser = __webpack_require__(21);
	var parseuri = __webpack_require__(2);
	var parseqs = __webpack_require__(30);

	/**
	 * Module exports.
	 */

	module.exports = Socket;

	/**
	 * Socket constructor.
	 *
	 * @param {String|Object} uri or options
	 * @param {Object} options
	 * @api public
	 */

	function Socket (uri, opts) {
	  if (!(this instanceof Socket)) return new Socket(uri, opts);

	  opts = opts || {};

	  if (uri && 'object' === typeof uri) {
	    opts = uri;
	    uri = null;
	  }

	  if (uri) {
	    uri = parseuri(uri);
	    opts.hostname = uri.host;
	    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
	    opts.port = uri.port;
	    if (uri.query) opts.query = uri.query;
	  } else if (opts.host) {
	    opts.hostname = parseuri(opts.host).host;
	  }

	  this.secure = null != opts.secure ? opts.secure
	    : (global.location && 'https:' === location.protocol);

	  if (opts.hostname && !opts.port) {
	    // if no port is specified manually, use the protocol default
	    opts.port = this.secure ? '443' : '80';
	  }

	  this.agent = opts.agent || false;
	  this.hostname = opts.hostname ||
	    (global.location ? location.hostname : 'localhost');
	  this.port = opts.port || (global.location && location.port
	      ? location.port
	      : (this.secure ? 443 : 80));
	  this.query = opts.query || {};
	  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
	  this.upgrade = false !== opts.upgrade;
	  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
	  this.forceJSONP = !!opts.forceJSONP;
	  this.jsonp = false !== opts.jsonp;
	  this.forceBase64 = !!opts.forceBase64;
	  this.enablesXDR = !!opts.enablesXDR;
	  this.timestampParam = opts.timestampParam || 't';
	  this.timestampRequests = opts.timestampRequests;
	  this.transports = opts.transports || ['polling', 'websocket'];
	  this.transportOptions = opts.transportOptions || {};
	  this.readyState = '';
	  this.writeBuffer = [];
	  this.prevBufferLen = 0;
	  this.policyPort = opts.policyPort || 843;
	  this.rememberUpgrade = opts.rememberUpgrade || false;
	  this.binaryType = null;
	  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
	  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

	  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
	  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
	    this.perMessageDeflate.threshold = 1024;
	  }

	  // SSL options for Node.js client
	  this.pfx = opts.pfx || null;
	  this.key = opts.key || null;
	  this.passphrase = opts.passphrase || null;
	  this.cert = opts.cert || null;
	  this.ca = opts.ca || null;
	  this.ciphers = opts.ciphers || null;
	  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
	  this.forceNode = !!opts.forceNode;

	  // other options for Node.js client
	  var freeGlobal = typeof global === 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
	      this.extraHeaders = opts.extraHeaders;
	    }

	    if (opts.localAddress) {
	      this.localAddress = opts.localAddress;
	    }
	  }

	  // set on handshake
	  this.id = null;
	  this.upgrades = null;
	  this.pingInterval = null;
	  this.pingTimeout = null;

	  // set on heartbeat
	  this.pingIntervalTimer = null;
	  this.pingTimeoutTimer = null;

	  this.open();
	}

	Socket.priorWebsocketSuccess = false;

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Protocol version.
	 *
	 * @api public
	 */

	Socket.protocol = parser.protocol; // this is an int

	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */

	Socket.Socket = Socket;
	Socket.Transport = __webpack_require__(20);
	Socket.transports = __webpack_require__(15);
	Socket.parser = __webpack_require__(21);

	/**
	 * Creates transport of the given type.
	 *
	 * @param {String} transport name
	 * @return {Transport}
	 * @api private
	 */

	Socket.prototype.createTransport = function (name) {
	  debug('creating transport "%s"', name);
	  var query = clone(this.query);

	  // append engine.io protocol identifier
	  query.EIO = parser.protocol;

	  // transport name
	  query.transport = name;

	  // per-transport options
	  var options = this.transportOptions[name] || {};

	  // session id if we already have one
	  if (this.id) query.sid = this.id;

	  var transport = new transports[name]({
	    query: query,
	    socket: this,
	    agent: options.agent || this.agent,
	    hostname: options.hostname || this.hostname,
	    port: options.port || this.port,
	    secure: options.secure || this.secure,
	    path: options.path || this.path,
	    forceJSONP: options.forceJSONP || this.forceJSONP,
	    jsonp: options.jsonp || this.jsonp,
	    forceBase64: options.forceBase64 || this.forceBase64,
	    enablesXDR: options.enablesXDR || this.enablesXDR,
	    timestampRequests: options.timestampRequests || this.timestampRequests,
	    timestampParam: options.timestampParam || this.timestampParam,
	    policyPort: options.policyPort || this.policyPort,
	    pfx: options.pfx || this.pfx,
	    key: options.key || this.key,
	    passphrase: options.passphrase || this.passphrase,
	    cert: options.cert || this.cert,
	    ca: options.ca || this.ca,
	    ciphers: options.ciphers || this.ciphers,
	    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
	    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
	    extraHeaders: options.extraHeaders || this.extraHeaders,
	    forceNode: options.forceNode || this.forceNode,
	    localAddress: options.localAddress || this.localAddress,
	    requestTimeout: options.requestTimeout || this.requestTimeout,
	    protocols: options.protocols || void (0)
	  });

	  return transport;
	};

	function clone (obj) {
	  var o = {};
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}

	/**
	 * Initializes transport to use and starts probe.
	 *
	 * @api private
	 */
	Socket.prototype.open = function () {
	  var transport;
	  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
	    transport = 'websocket';
	  } else if (0 === this.transports.length) {
	    // Emit error on next tick so it can be listened to
	    var self = this;
	    setTimeout(function () {
	      self.emit('error', 'No transports available');
	    }, 0);
	    return;
	  } else {
	    transport = this.transports[0];
	  }
	  this.readyState = 'opening';

	  // Retry with the next transport if the transport is disabled (jsonp: false)
	  try {
	    transport = this.createTransport(transport);
	  } catch (e) {
	    this.transports.shift();
	    this.open();
	    return;
	  }

	  transport.open();
	  this.setTransport(transport);
	};

	/**
	 * Sets the current transport. Disables the existing one (if any).
	 *
	 * @api private
	 */

	Socket.prototype.setTransport = function (transport) {
	  debug('setting transport %s', transport.name);
	  var self = this;

	  if (this.transport) {
	    debug('clearing existing transport %s', this.transport.name);
	    this.transport.removeAllListeners();
	  }

	  // set up transport
	  this.transport = transport;

	  // set up transport listeners
	  transport
	  .on('drain', function () {
	    self.onDrain();
	  })
	  .on('packet', function (packet) {
	    self.onPacket(packet);
	  })
	  .on('error', function (e) {
	    self.onError(e);
	  })
	  .on('close', function () {
	    self.onClose('transport close');
	  });
	};

	/**
	 * Probes a transport.
	 *
	 * @param {String} transport name
	 * @api private
	 */

	Socket.prototype.probe = function (name) {
	  debug('probing transport "%s"', name);
	  var transport = this.createTransport(name, { probe: 1 });
	  var failed = false;
	  var self = this;

	  Socket.priorWebsocketSuccess = false;

	  function onTransportOpen () {
	    if (self.onlyBinaryUpgrades) {
	      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
	      failed = failed || upgradeLosesBinary;
	    }
	    if (failed) return;

	    debug('probe transport "%s" opened', name);
	    transport.send([{ type: 'ping', data: 'probe' }]);
	    transport.once('packet', function (msg) {
	      if (failed) return;
	      if ('pong' === msg.type && 'probe' === msg.data) {
	        debug('probe transport "%s" pong', name);
	        self.upgrading = true;
	        self.emit('upgrading', transport);
	        if (!transport) return;
	        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

	        debug('pausing current transport "%s"', self.transport.name);
	        self.transport.pause(function () {
	          if (failed) return;
	          if ('closed' === self.readyState) return;
	          debug('changing transport and sending upgrade packet');

	          cleanup();

	          self.setTransport(transport);
	          transport.send([{ type: 'upgrade' }]);
	          self.emit('upgrade', transport);
	          transport = null;
	          self.upgrading = false;
	          self.flush();
	        });
	      } else {
	        debug('probe transport "%s" failed', name);
	        var err = new Error('probe error');
	        err.transport = transport.name;
	        self.emit('upgradeError', err);
	      }
	    });
	  }

	  function freezeTransport () {
	    if (failed) return;

	    // Any callback called by transport should be ignored since now
	    failed = true;

	    cleanup();

	    transport.close();
	    transport = null;
	  }

	  // Handle any error that happens while probing
	  function onerror (err) {
	    var error = new Error('probe error: ' + err);
	    error.transport = transport.name;

	    freezeTransport();

	    debug('probe transport "%s" failed because of error: %s', name, err);

	    self.emit('upgradeError', error);
	  }

	  function onTransportClose () {
	    onerror('transport closed');
	  }

	  // When the socket is closed while we're probing
	  function onclose () {
	    onerror('socket closed');
	  }

	  // When the socket is upgraded while we're probing
	  function onupgrade (to) {
	    if (transport && to.name !== transport.name) {
	      debug('"%s" works - aborting "%s"', to.name, transport.name);
	      freezeTransport();
	    }
	  }

	  // Remove all listeners on the transport and on self
	  function cleanup () {
	    transport.removeListener('open', onTransportOpen);
	    transport.removeListener('error', onerror);
	    transport.removeListener('close', onTransportClose);
	    self.removeListener('close', onclose);
	    self.removeListener('upgrading', onupgrade);
	  }

	  transport.once('open', onTransportOpen);
	  transport.once('error', onerror);
	  transport.once('close', onTransportClose);

	  this.once('close', onclose);
	  this.once('upgrading', onupgrade);

	  transport.open();
	};

	/**
	 * Called when connection is deemed open.
	 *
	 * @api public
	 */

	Socket.prototype.onOpen = function () {
	  debug('socket open');
	  this.readyState = 'open';
	  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
	  this.emit('open');
	  this.flush();

	  // we check for `readyState` in case an `open`
	  // listener already closed the socket
	  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
	    debug('starting upgrade probes');
	    for (var i = 0, l = this.upgrades.length; i < l; i++) {
	      this.probe(this.upgrades[i]);
	    }
	  }
	};

	/**
	 * Handles a packet.
	 *
	 * @api private
	 */

	Socket.prototype.onPacket = function (packet) {
	  if ('opening' === this.readyState || 'open' === this.readyState ||
	      'closing' === this.readyState) {
	    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

	    this.emit('packet', packet);

	    // Socket is live - any packet counts
	    this.emit('heartbeat');

	    switch (packet.type) {
	      case 'open':
	        this.onHandshake(JSON.parse(packet.data));
	        break;

	      case 'pong':
	        this.setPing();
	        this.emit('pong');
	        break;

	      case 'error':
	        var err = new Error('server error');
	        err.code = packet.data;
	        this.onError(err);
	        break;

	      case 'message':
	        this.emit('data', packet.data);
	        this.emit('message', packet.data);
	        break;
	    }
	  } else {
	    debug('packet received with socket readyState "%s"', this.readyState);
	  }
	};

	/**
	 * Called upon handshake completion.
	 *
	 * @param {Object} handshake obj
	 * @api private
	 */

	Socket.prototype.onHandshake = function (data) {
	  this.emit('handshake', data);
	  this.id = data.sid;
	  this.transport.query.sid = data.sid;
	  this.upgrades = this.filterUpgrades(data.upgrades);
	  this.pingInterval = data.pingInterval;
	  this.pingTimeout = data.pingTimeout;
	  this.onOpen();
	  // In case open handler closes socket
	  if ('closed' === this.readyState) return;
	  this.setPing();

	  // Prolong liveness of socket on heartbeat
	  this.removeListener('heartbeat', this.onHeartbeat);
	  this.on('heartbeat', this.onHeartbeat);
	};

	/**
	 * Resets ping timeout.
	 *
	 * @api private
	 */

	Socket.prototype.onHeartbeat = function (timeout) {
	  clearTimeout(this.pingTimeoutTimer);
	  var self = this;
	  self.pingTimeoutTimer = setTimeout(function () {
	    if ('closed' === self.readyState) return;
	    self.onClose('ping timeout');
	  }, timeout || (self.pingInterval + self.pingTimeout));
	};

	/**
	 * Pings server every `this.pingInterval` and expects response
	 * within `this.pingTimeout` or closes connection.
	 *
	 * @api private
	 */

	Socket.prototype.setPing = function () {
	  var self = this;
	  clearTimeout(self.pingIntervalTimer);
	  self.pingIntervalTimer = setTimeout(function () {
	    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
	    self.ping();
	    self.onHeartbeat(self.pingTimeout);
	  }, self.pingInterval);
	};

	/**
	* Sends a ping packet.
	*
	* @api private
	*/

	Socket.prototype.ping = function () {
	  var self = this;
	  this.sendPacket('ping', function () {
	    self.emit('ping');
	  });
	};

	/**
	 * Called on `drain` event
	 *
	 * @api private
	 */

	Socket.prototype.onDrain = function () {
	  this.writeBuffer.splice(0, this.prevBufferLen);

	  // setting prevBufferLen = 0 is very important
	  // for example, when upgrading, upgrade packet is sent over,
	  // and a nonzero prevBufferLen could cause problems on `drain`
	  this.prevBufferLen = 0;

	  if (0 === this.writeBuffer.length) {
	    this.emit('drain');
	  } else {
	    this.flush();
	  }
	};

	/**
	 * Flush write buffers.
	 *
	 * @api private
	 */

	Socket.prototype.flush = function () {
	  if ('closed' !== this.readyState && this.transport.writable &&
	    !this.upgrading && this.writeBuffer.length) {
	    debug('flushing %d packets in socket', this.writeBuffer.length);
	    this.transport.send(this.writeBuffer);
	    // keep track of current length of writeBuffer
	    // splice writeBuffer and callbackBuffer on `drain`
	    this.prevBufferLen = this.writeBuffer.length;
	    this.emit('flush');
	  }
	};

	/**
	 * Sends a message.
	 *
	 * @param {String} message.
	 * @param {Function} callback function.
	 * @param {Object} options.
	 * @return {Socket} for chaining.
	 * @api public
	 */

	Socket.prototype.write =
	Socket.prototype.send = function (msg, options, fn) {
	  this.sendPacket('message', msg, options, fn);
	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {String} packet type.
	 * @param {String} data.
	 * @param {Object} options.
	 * @param {Function} callback function.
	 * @api private
	 */

	Socket.prototype.sendPacket = function (type, data, options, fn) {
	  if ('function' === typeof data) {
	    fn = data;
	    data = undefined;
	  }

	  if ('function' === typeof options) {
	    fn = options;
	    options = null;
	  }

	  if ('closing' === this.readyState || 'closed' === this.readyState) {
	    return;
	  }

	  options = options || {};
	  options.compress = false !== options.compress;

	  var packet = {
	    type: type,
	    data: data,
	    options: options
	  };
	  this.emit('packetCreate', packet);
	  this.writeBuffer.push(packet);
	  if (fn) this.once('flush', fn);
	  this.flush();
	};

	/**
	 * Closes the connection.
	 *
	 * @api private
	 */

	Socket.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.readyState = 'closing';

	    var self = this;

	    if (this.writeBuffer.length) {
	      this.once('drain', function () {
	        if (this.upgrading) {
	          waitForUpgrade();
	        } else {
	          close();
	        }
	      });
	    } else if (this.upgrading) {
	      waitForUpgrade();
	    } else {
	      close();
	    }
	  }

	  function close () {
	    self.onClose('forced close');
	    debug('socket closing - telling transport to close');
	    self.transport.close();
	  }

	  function cleanupAndClose () {
	    self.removeListener('upgrade', cleanupAndClose);
	    self.removeListener('upgradeError', cleanupAndClose);
	    close();
	  }

	  function waitForUpgrade () {
	    // wait for upgrade to finish since we can't send packets while pausing a transport
	    self.once('upgrade', cleanupAndClose);
	    self.once('upgradeError', cleanupAndClose);
	  }

	  return this;
	};

	/**
	 * Called upon transport error
	 *
	 * @api private
	 */

	Socket.prototype.onError = function (err) {
	  debug('socket error %j', err);
	  Socket.priorWebsocketSuccess = false;
	  this.emit('error', err);
	  this.onClose('transport error', err);
	};

	/**
	 * Called upon transport close.
	 *
	 * @api private
	 */

	Socket.prototype.onClose = function (reason, desc) {
	  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
	    debug('socket close with reason: "%s"', reason);
	    var self = this;

	    // clear timers
	    clearTimeout(this.pingIntervalTimer);
	    clearTimeout(this.pingTimeoutTimer);

	    // stop event from firing again for transport
	    this.transport.removeAllListeners('close');

	    // ensure transport won't stay open
	    this.transport.close();

	    // ignore further transport communication
	    this.transport.removeAllListeners();

	    // set ready state
	    this.readyState = 'closed';

	    // clear session id
	    this.id = null;

	    // emit close event
	    this.emit('close', reason, desc);

	    // clean buffers after, so users can still
	    // grab the buffers on `close` event
	    self.writeBuffer = [];
	    self.prevBufferLen = 0;
	  }
	};

	/**
	 * Filters upgrades, returning only those matching client transports.
	 *
	 * @param {Array} server upgrades
	 * @api private
	 *
	 */

	Socket.prototype.filterUpgrades = function (upgrades) {
	  var filteredUpgrades = [];
	  for (var i = 0, j = upgrades.length; i < j; i++) {
	    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
	  }
	  return filteredUpgrades;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies
	 */

	var XMLHttpRequest = __webpack_require__(16);
	var XHR = __webpack_require__(18);
	var JSONP = __webpack_require__(33);
	var websocket = __webpack_require__(34);

	/**
	 * Export transports.
	 */

	exports.polling = polling;
	exports.websocket = websocket;

	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */

	function polling (opts) {
	  var xhr;
	  var xd = false;
	  var xs = false;
	  var jsonp = false !== opts.jsonp;

	  if (global.location) {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    xd = opts.hostname !== location.hostname || port !== opts.port;
	    xs = opts.secure !== isSSL;
	  }

	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);

	  if ('open' in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error('JSONP disabled');
	    return new JSONP(opts);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module

	var hasCORS = __webpack_require__(17);

	module.exports = function (opts) {
	  var xdomain = opts.xdomain;

	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  var xscheme = opts.xscheme;

	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  var enablesXDR = opts.enablesXDR;

	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) { }

	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) { }

	  if (!xdomain) {
	    try {
	      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
	    } catch (e) { }
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 17 */
/***/ (function(module, exports) {


	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */

	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module requirements.
	 */

	var XMLHttpRequest = __webpack_require__(16);
	var Polling = __webpack_require__(19);
	var Emitter = __webpack_require__(8);
	var inherit = __webpack_require__(31);
	var debug = __webpack_require__(3)('engine.io-client:polling-xhr');

	/**
	 * Module exports.
	 */

	module.exports = XHR;
	module.exports.Request = Request;

	/**
	 * Empty function
	 */

	function empty () {}

	/**
	 * XHR Polling constructor.
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function XHR (opts) {
	  Polling.call(this, opts);
	  this.requestTimeout = opts.requestTimeout;
	  this.extraHeaders = opts.extraHeaders;

	  if (global.location) {
	    var isSSL = 'https:' === location.protocol;
	    var port = location.port;

	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }

	    this.xd = opts.hostname !== global.location.hostname ||
	      port !== opts.port;
	    this.xs = opts.secure !== isSSL;
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(XHR, Polling);

	/**
	 * XHR supports binary
	 */

	XHR.prototype.supportsBinary = true;

	/**
	 * Creates a request.
	 *
	 * @param {String} method
	 * @api private
	 */

	XHR.prototype.request = function (opts) {
	  opts = opts || {};
	  opts.uri = this.uri();
	  opts.xd = this.xd;
	  opts.xs = this.xs;
	  opts.agent = this.agent || false;
	  opts.supportsBinary = this.supportsBinary;
	  opts.enablesXDR = this.enablesXDR;

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  opts.requestTimeout = this.requestTimeout;

	  // other options for Node.js client
	  opts.extraHeaders = this.extraHeaders;

	  return new Request(opts);
	};

	/**
	 * Sends data.
	 *
	 * @param {String} data to send.
	 * @param {Function} called upon flush.
	 * @api private
	 */

	XHR.prototype.doWrite = function (data, fn) {
	  var isBinary = typeof data !== 'string' && data !== undefined;
	  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
	  var self = this;
	  req.on('success', fn);
	  req.on('error', function (err) {
	    self.onError('xhr post error', err);
	  });
	  this.sendXhr = req;
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	XHR.prototype.doPoll = function () {
	  debug('xhr poll');
	  var req = this.request();
	  var self = this;
	  req.on('data', function (data) {
	    self.onData(data);
	  });
	  req.on('error', function (err) {
	    self.onError('xhr poll error', err);
	  });
	  this.pollXhr = req;
	};

	/**
	 * Request constructor
	 *
	 * @param {Object} options
	 * @api public
	 */

	function Request (opts) {
	  this.method = opts.method || 'GET';
	  this.uri = opts.uri;
	  this.xd = !!opts.xd;
	  this.xs = !!opts.xs;
	  this.async = false !== opts.async;
	  this.data = undefined !== opts.data ? opts.data : null;
	  this.agent = opts.agent;
	  this.isBinary = opts.isBinary;
	  this.supportsBinary = opts.supportsBinary;
	  this.enablesXDR = opts.enablesXDR;
	  this.requestTimeout = opts.requestTimeout;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;

	  this.create();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Request.prototype);

	/**
	 * Creates the XHR object and sends the request.
	 *
	 * @api private
	 */

	Request.prototype.create = function () {
	  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;

	  var xhr = this.xhr = new XMLHttpRequest(opts);
	  var self = this;

	  try {
	    debug('xhr open %s: %s', this.method, this.uri);
	    xhr.open(this.method, this.uri, this.async);
	    try {
	      if (this.extraHeaders) {
	        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
	        for (var i in this.extraHeaders) {
	          if (this.extraHeaders.hasOwnProperty(i)) {
	            xhr.setRequestHeader(i, this.extraHeaders[i]);
	          }
	        }
	      }
	    } catch (e) {}

	    if ('POST' === this.method) {
	      try {
	        if (this.isBinary) {
	          xhr.setRequestHeader('Content-type', 'application/octet-stream');
	        } else {
	          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
	        }
	      } catch (e) {}
	    }

	    try {
	      xhr.setRequestHeader('Accept', '*/*');
	    } catch (e) {}

	    // ie6 check
	    if ('withCredentials' in xhr) {
	      xhr.withCredentials = true;
	    }

	    if (this.requestTimeout) {
	      xhr.timeout = this.requestTimeout;
	    }

	    if (this.hasXDR()) {
	      xhr.onload = function () {
	        self.onLoad();
	      };
	      xhr.onerror = function () {
	        self.onError(xhr.responseText);
	      };
	    } else {
	      xhr.onreadystatechange = function () {
	        if (xhr.readyState === 2) {
	          try {
	            var contentType = xhr.getResponseHeader('Content-Type');
	            if (self.supportsBinary && contentType === 'application/octet-stream') {
	              xhr.responseType = 'arraybuffer';
	            }
	          } catch (e) {}
	        }
	        if (4 !== xhr.readyState) return;
	        if (200 === xhr.status || 1223 === xhr.status) {
	          self.onLoad();
	        } else {
	          // make sure the `error` event handler that's user-set
	          // does not throw in the same tick and gets caught here
	          setTimeout(function () {
	            self.onError(xhr.status);
	          }, 0);
	        }
	      };
	    }

	    debug('xhr data %s', this.data);
	    xhr.send(this.data);
	  } catch (e) {
	    // Need to defer since .create() is called directly fhrom the constructor
	    // and thus the 'error' event can only be only bound *after* this exception
	    // occurs.  Therefore, also, we cannot throw here at all.
	    setTimeout(function () {
	      self.onError(e);
	    }, 0);
	    return;
	  }

	  if (global.document) {
	    this.index = Request.requestsCount++;
	    Request.requests[this.index] = this;
	  }
	};

	/**
	 * Called upon successful response.
	 *
	 * @api private
	 */

	Request.prototype.onSuccess = function () {
	  this.emit('success');
	  this.cleanup();
	};

	/**
	 * Called if we have data.
	 *
	 * @api private
	 */

	Request.prototype.onData = function (data) {
	  this.emit('data', data);
	  this.onSuccess();
	};

	/**
	 * Called upon error.
	 *
	 * @api private
	 */

	Request.prototype.onError = function (err) {
	  this.emit('error', err);
	  this.cleanup(true);
	};

	/**
	 * Cleans up house.
	 *
	 * @api private
	 */

	Request.prototype.cleanup = function (fromError) {
	  if ('undefined' === typeof this.xhr || null === this.xhr) {
	    return;
	  }
	  // xmlhttprequest
	  if (this.hasXDR()) {
	    this.xhr.onload = this.xhr.onerror = empty;
	  } else {
	    this.xhr.onreadystatechange = empty;
	  }

	  if (fromError) {
	    try {
	      this.xhr.abort();
	    } catch (e) {}
	  }

	  if (global.document) {
	    delete Request.requests[this.index];
	  }

	  this.xhr = null;
	};

	/**
	 * Called upon load.
	 *
	 * @api private
	 */

	Request.prototype.onLoad = function () {
	  var data;
	  try {
	    var contentType;
	    try {
	      contentType = this.xhr.getResponseHeader('Content-Type');
	    } catch (e) {}
	    if (contentType === 'application/octet-stream') {
	      data = this.xhr.response || this.xhr.responseText;
	    } else {
	      data = this.xhr.responseText;
	    }
	  } catch (e) {
	    this.onError(e);
	  }
	  if (null != data) {
	    this.onData(data);
	  }
	};

	/**
	 * Check if it has XDomainRequest.
	 *
	 * @api private
	 */

	Request.prototype.hasXDR = function () {
	  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
	};

	/**
	 * Aborts the request.
	 *
	 * @api public
	 */

	Request.prototype.abort = function () {
	  this.cleanup();
	};

	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */

	Request.requestsCount = 0;
	Request.requests = {};

	if (global.document) {
	  if (global.attachEvent) {
	    global.attachEvent('onunload', unloadHandler);
	  } else if (global.addEventListener) {
	    global.addEventListener('beforeunload', unloadHandler, false);
	  }
	}

	function unloadHandler () {
	  for (var i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(20);
	var parseqs = __webpack_require__(30);
	var parser = __webpack_require__(21);
	var inherit = __webpack_require__(31);
	var yeast = __webpack_require__(32);
	var debug = __webpack_require__(3)('engine.io-client:polling');

	/**
	 * Module exports.
	 */

	module.exports = Polling;

	/**
	 * Is XHR2 supported?
	 */

	var hasXHR2 = (function () {
	  var XMLHttpRequest = __webpack_require__(16);
	  var xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();

	/**
	 * Polling interface.
	 *
	 * @param {Object} opts
	 * @api private
	 */

	function Polling (opts) {
	  var forceBase64 = (opts && opts.forceBase64);
	  if (!hasXHR2 || forceBase64) {
	    this.supportsBinary = false;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(Polling, Transport);

	/**
	 * Transport name.
	 */

	Polling.prototype.name = 'polling';

	/**
	 * Opens the socket (triggers polling). We write a PING message to determine
	 * when the transport is open.
	 *
	 * @api private
	 */

	Polling.prototype.doOpen = function () {
	  this.poll();
	};

	/**
	 * Pauses polling.
	 *
	 * @param {Function} callback upon buffers are flushed and transport is paused
	 * @api private
	 */

	Polling.prototype.pause = function (onPause) {
	  var self = this;

	  this.readyState = 'pausing';

	  function pause () {
	    debug('paused');
	    self.readyState = 'paused';
	    onPause();
	  }

	  if (this.polling || !this.writable) {
	    var total = 0;

	    if (this.polling) {
	      debug('we are currently polling - waiting to pause');
	      total++;
	      this.once('pollComplete', function () {
	        debug('pre-pause polling complete');
	        --total || pause();
	      });
	    }

	    if (!this.writable) {
	      debug('we are currently writing - waiting to pause');
	      total++;
	      this.once('drain', function () {
	        debug('pre-pause writing complete');
	        --total || pause();
	      });
	    }
	  } else {
	    pause();
	  }
	};

	/**
	 * Starts polling cycle.
	 *
	 * @api public
	 */

	Polling.prototype.poll = function () {
	  debug('polling');
	  this.polling = true;
	  this.doPoll();
	  this.emit('poll');
	};

	/**
	 * Overloads onData to detect payloads.
	 *
	 * @api private
	 */

	Polling.prototype.onData = function (data) {
	  var self = this;
	  debug('polling got data %s', data);
	  var callback = function (packet, index, total) {
	    // if its the first message we consider the transport open
	    if ('opening' === self.readyState) {
	      self.onOpen();
	    }

	    // if its a close packet, we close the ongoing requests
	    if ('close' === packet.type) {
	      self.onClose();
	      return false;
	    }

	    // otherwise bypass onData and handle the message
	    self.onPacket(packet);
	  };

	  // decode payload
	  parser.decodePayload(data, this.socket.binaryType, callback);

	  // if an event did not trigger closing
	  if ('closed' !== this.readyState) {
	    // if we got data we're not polling
	    this.polling = false;
	    this.emit('pollComplete');

	    if ('open' === this.readyState) {
	      this.poll();
	    } else {
	      debug('ignoring poll - transport state "%s"', this.readyState);
	    }
	  }
	};

	/**
	 * For polling, send a close packet.
	 *
	 * @api private
	 */

	Polling.prototype.doClose = function () {
	  var self = this;

	  function close () {
	    debug('writing close packet');
	    self.write([{ type: 'close' }]);
	  }

	  if ('open' === this.readyState) {
	    debug('transport open - closing');
	    close();
	  } else {
	    // in case we're trying to close while
	    // handshaking is in progress (GH-164)
	    debug('transport not open - deferring close');
	    this.once('open', close);
	  }
	};

	/**
	 * Writes a packets payload.
	 *
	 * @param {Array} data packets
	 * @param {Function} drain callback
	 * @api private
	 */

	Polling.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;
	  var callbackfn = function () {
	    self.writable = true;
	    self.emit('drain');
	  };

	  parser.encodePayload(packets, this.supportsBinary, function (data) {
	    self.doWrite(data, callbackfn);
	  });
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	Polling.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'https' : 'http';
	  var port = '';

	  // cache busting is forced
	  if (false !== this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  if (!this.supportsBinary && !query.sid) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // avoid port if default for schema
	  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
	     ('http' === schema && Number(this.port) !== 80))) {
	    port = ':' + this.port;
	  }

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(21);
	var Emitter = __webpack_require__(8);

	/**
	 * Module exports.
	 */

	module.exports = Transport;

	/**
	 * Transport abstract constructor.
	 *
	 * @param {Object} options.
	 * @api private
	 */

	function Transport (opts) {
	  this.path = opts.path;
	  this.hostname = opts.hostname;
	  this.port = opts.port;
	  this.secure = opts.secure;
	  this.query = opts.query;
	  this.timestampParam = opts.timestampParam;
	  this.timestampRequests = opts.timestampRequests;
	  this.readyState = '';
	  this.agent = opts.agent || false;
	  this.socket = opts.socket;
	  this.enablesXDR = opts.enablesXDR;

	  // SSL options for Node.js client
	  this.pfx = opts.pfx;
	  this.key = opts.key;
	  this.passphrase = opts.passphrase;
	  this.cert = opts.cert;
	  this.ca = opts.ca;
	  this.ciphers = opts.ciphers;
	  this.rejectUnauthorized = opts.rejectUnauthorized;
	  this.forceNode = opts.forceNode;

	  // other options for Node.js client
	  this.extraHeaders = opts.extraHeaders;
	  this.localAddress = opts.localAddress;
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Transport.prototype);

	/**
	 * Emits an error.
	 *
	 * @param {String} str
	 * @return {Transport} for chaining
	 * @api public
	 */

	Transport.prototype.onError = function (msg, desc) {
	  var err = new Error(msg);
	  err.type = 'TransportError';
	  err.description = desc;
	  this.emit('error', err);
	  return this;
	};

	/**
	 * Opens the transport.
	 *
	 * @api public
	 */

	Transport.prototype.open = function () {
	  if ('closed' === this.readyState || '' === this.readyState) {
	    this.readyState = 'opening';
	    this.doOpen();
	  }

	  return this;
	};

	/**
	 * Closes the transport.
	 *
	 * @api private
	 */

	Transport.prototype.close = function () {
	  if ('opening' === this.readyState || 'open' === this.readyState) {
	    this.doClose();
	    this.onClose();
	  }

	  return this;
	};

	/**
	 * Sends multiple packets.
	 *
	 * @param {Array} packets
	 * @api private
	 */

	Transport.prototype.send = function (packets) {
	  if ('open' === this.readyState) {
	    this.write(packets);
	  } else {
	    throw new Error('Transport not open');
	  }
	};

	/**
	 * Called upon open
	 *
	 * @api private
	 */

	Transport.prototype.onOpen = function () {
	  this.readyState = 'open';
	  this.writable = true;
	  this.emit('open');
	};

	/**
	 * Called with data.
	 *
	 * @param {String} data
	 * @api private
	 */

	Transport.prototype.onData = function (data) {
	  var packet = parser.decodePacket(data, this.socket.binaryType);
	  this.onPacket(packet);
	};

	/**
	 * Called with a decoded packet.
	 */

	Transport.prototype.onPacket = function (packet) {
	  this.emit('packet', packet);
	};

	/**
	 * Called upon close.
	 *
	 * @api private
	 */

	Transport.prototype.onClose = function () {
	  this.readyState = 'closed';
	  this.emit('close');
	};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var keys = __webpack_require__(22);
	var hasBinary = __webpack_require__(23);
	var sliceBuffer = __webpack_require__(24);
	var after = __webpack_require__(25);
	var utf8 = __webpack_require__(26);

	var base64encoder;
	if (global && global.ArrayBuffer) {
	  base64encoder = __webpack_require__(28);
	}

	/**
	 * Check if we are running an android browser. That requires us to use
	 * ArrayBuffer with polling transports...
	 *
	 * http://ghinda.net/jpeg-blob-ajax-android/
	 */

	var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

	/**
	 * Check if we are running in PhantomJS.
	 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
	 * https://github.com/ariya/phantomjs/issues/11395
	 * @type boolean
	 */
	var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

	/**
	 * When true, avoids using Blobs to encode payloads.
	 * @type boolean
	 */
	var dontSendBlobs = isAndroid || isPhantomJS;

	/**
	 * Current protocol version.
	 */

	exports.protocol = 3;

	/**
	 * Packet types.
	 */

	var packets = exports.packets = {
	    open:     0    // non-ws
	  , close:    1    // non-ws
	  , ping:     2
	  , pong:     3
	  , message:  4
	  , upgrade:  5
	  , noop:     6
	};

	var packetslist = keys(packets);

	/**
	 * Premade error packet.
	 */

	var err = { type: 'error', data: 'parser error' };

	/**
	 * Create a blob api even for blob builder when vendor prefixes exist
	 */

	var Blob = __webpack_require__(29);

	/**
	 * Encodes a packet.
	 *
	 *     <packet type id> [ <data> ]
	 *
	 * Example:
	 *
	 *     5hello world
	 *     3
	 *     4
	 *
	 * Binary is encoded in an identical principle
	 *
	 * @api private
	 */

	exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
	  if (typeof supportsBinary === 'function') {
	    callback = supportsBinary;
	    supportsBinary = false;
	  }

	  if (typeof utf8encode === 'function') {
	    callback = utf8encode;
	    utf8encode = null;
	  }

	  var data = (packet.data === undefined)
	    ? undefined
	    : packet.data.buffer || packet.data;

	  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
	    return encodeArrayBuffer(packet, supportsBinary, callback);
	  } else if (Blob && data instanceof global.Blob) {
	    return encodeBlob(packet, supportsBinary, callback);
	  }

	  // might be an object with { base64: true, data: dataAsBase64String }
	  if (data && data.base64) {
	    return encodeBase64Object(packet, callback);
	  }

	  // Sending data as a utf-8 string
	  var encoded = packets[packet.type];

	  // data fragment is optional
	  if (undefined !== packet.data) {
	    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
	  }

	  return callback('' + encoded);

	};

	function encodeBase64Object(packet, callback) {
	  // packet data is an object { base64: true, data: dataAsBase64String }
	  var message = 'b' + exports.packets[packet.type] + packet.data.data;
	  return callback(message);
	}

	/**
	 * Encode packet helpers for binary types
	 */

	function encodeArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var data = packet.data;
	  var contentArray = new Uint8Array(data);
	  var resultBuffer = new Uint8Array(1 + data.byteLength);

	  resultBuffer[0] = packets[packet.type];
	  for (var i = 0; i < contentArray.length; i++) {
	    resultBuffer[i+1] = contentArray[i];
	  }

	  return callback(resultBuffer.buffer);
	}

	function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  var fr = new FileReader();
	  fr.onload = function() {
	    packet.data = fr.result;
	    exports.encodePacket(packet, supportsBinary, true, callback);
	  };
	  return fr.readAsArrayBuffer(packet.data);
	}

	function encodeBlob(packet, supportsBinary, callback) {
	  if (!supportsBinary) {
	    return exports.encodeBase64Packet(packet, callback);
	  }

	  if (dontSendBlobs) {
	    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
	  }

	  var length = new Uint8Array(1);
	  length[0] = packets[packet.type];
	  var blob = new Blob([length.buffer, packet.data]);

	  return callback(blob);
	}

	/**
	 * Encodes a packet with binary data in a base64 string
	 *
	 * @param {Object} packet, has `type` and `data`
	 * @return {String} base64 encoded message
	 */

	exports.encodeBase64Packet = function(packet, callback) {
	  var message = 'b' + exports.packets[packet.type];
	  if (Blob && packet.data instanceof global.Blob) {
	    var fr = new FileReader();
	    fr.onload = function() {
	      var b64 = fr.result.split(',')[1];
	      callback(message + b64);
	    };
	    return fr.readAsDataURL(packet.data);
	  }

	  var b64data;
	  try {
	    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
	  } catch (e) {
	    // iPhone Safari doesn't let you apply with typed arrays
	    var typed = new Uint8Array(packet.data);
	    var basic = new Array(typed.length);
	    for (var i = 0; i < typed.length; i++) {
	      basic[i] = typed[i];
	    }
	    b64data = String.fromCharCode.apply(null, basic);
	  }
	  message += global.btoa(b64data);
	  return callback(message);
	};

	/**
	 * Decodes a packet. Changes format to Blob if requested.
	 *
	 * @return {Object} with `type` and `data` (if any)
	 * @api private
	 */

	exports.decodePacket = function (data, binaryType, utf8decode) {
	  if (data === undefined) {
	    return err;
	  }
	  // String data
	  if (typeof data === 'string') {
	    if (data.charAt(0) === 'b') {
	      return exports.decodeBase64Packet(data.substr(1), binaryType);
	    }

	    if (utf8decode) {
	      data = tryDecode(data);
	      if (data === false) {
	        return err;
	      }
	    }
	    var type = data.charAt(0);

	    if (Number(type) != type || !packetslist[type]) {
	      return err;
	    }

	    if (data.length > 1) {
	      return { type: packetslist[type], data: data.substring(1) };
	    } else {
	      return { type: packetslist[type] };
	    }
	  }

	  var asArray = new Uint8Array(data);
	  var type = asArray[0];
	  var rest = sliceBuffer(data, 1);
	  if (Blob && binaryType === 'blob') {
	    rest = new Blob([rest]);
	  }
	  return { type: packetslist[type], data: rest };
	};

	function tryDecode(data) {
	  try {
	    data = utf8.decode(data, { strict: false });
	  } catch (e) {
	    return false;
	  }
	  return data;
	}

	/**
	 * Decodes a packet encoded in a base64 string
	 *
	 * @param {String} base64 encoded message
	 * @return {Object} with `type` and `data` (if any)
	 */

	exports.decodeBase64Packet = function(msg, binaryType) {
	  var type = packetslist[msg.charAt(0)];
	  if (!base64encoder) {
	    return { type: type, data: { base64: true, data: msg.substr(1) } };
	  }

	  var data = base64encoder.decode(msg.substr(1));

	  if (binaryType === 'blob' && Blob) {
	    data = new Blob([data]);
	  }

	  return { type: type, data: data };
	};

	/**
	 * Encodes multiple messages (payload).
	 *
	 *     <length>:data
	 *
	 * Example:
	 *
	 *     11:hello world2:hi
	 *
	 * If any contents are binary, they will be encoded as base64 strings. Base64
	 * encoded strings are marked with a b before the length specifier
	 *
	 * @param {Array} packets
	 * @api private
	 */

	exports.encodePayload = function (packets, supportsBinary, callback) {
	  if (typeof supportsBinary === 'function') {
	    callback = supportsBinary;
	    supportsBinary = null;
	  }

	  var isBinary = hasBinary(packets);

	  if (supportsBinary && isBinary) {
	    if (Blob && !dontSendBlobs) {
	      return exports.encodePayloadAsBlob(packets, callback);
	    }

	    return exports.encodePayloadAsArrayBuffer(packets, callback);
	  }

	  if (!packets.length) {
	    return callback('0:');
	  }

	  function setLengthHeader(message) {
	    return message.length + ':' + message;
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
	      doneCallback(null, setLengthHeader(message));
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(results.join(''));
	  });
	};

	/**
	 * Async array map using after
	 */

	function map(ary, each, done) {
	  var result = new Array(ary.length);
	  var next = after(ary.length, done);

	  var eachWithIndex = function(i, el, cb) {
	    each(el, function(error, msg) {
	      result[i] = msg;
	      cb(error, result);
	    });
	  };

	  for (var i = 0; i < ary.length; i++) {
	    eachWithIndex(i, ary[i], next);
	  }
	}

	/*
	 * Decodes data when a payload is maybe expected. Possible binary contents are
	 * decoded from their base64 representation
	 *
	 * @param {String} data, callback method
	 * @api public
	 */

	exports.decodePayload = function (data, binaryType, callback) {
	  if (typeof data !== 'string') {
	    return exports.decodePayloadAsBinary(data, binaryType, callback);
	  }

	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var packet;
	  if (data === '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	  var length = '', n, msg;

	  for (var i = 0, l = data.length; i < l; i++) {
	    var chr = data.charAt(i);

	    if (chr !== ':') {
	      length += chr;
	      continue;
	    }

	    if (length === '' || (length != (n = Number(length)))) {
	      // parser error - ignoring payload
	      return callback(err, 0, 1);
	    }

	    msg = data.substr(i + 1, n);

	    if (length != msg.length) {
	      // parser error - ignoring payload
	      return callback(err, 0, 1);
	    }

	    if (msg.length) {
	      packet = exports.decodePacket(msg, binaryType, false);

	      if (err.type === packet.type && err.data === packet.data) {
	        // parser error in individual packet - ignoring payload
	        return callback(err, 0, 1);
	      }

	      var ret = callback(packet, i + n, l);
	      if (false === ret) return;
	    }

	    // advance cursor
	    i += n;
	    length = '';
	  }

	  if (length !== '') {
	    // parser error - ignoring payload
	    return callback(err, 0, 1);
	  }

	};

	/**
	 * Encodes multiple messages (payload) as binary.
	 *
	 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
	 * 255><data>
	 *
	 * Example:
	 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
	 *
	 * @param {Array} packets
	 * @return {ArrayBuffer} encoded payload
	 * @api private
	 */

	exports.encodePayloadAsArrayBuffer = function(packets, callback) {
	  if (!packets.length) {
	    return callback(new ArrayBuffer(0));
	  }

	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(data) {
	      return doneCallback(null, data);
	    });
	  }

	  map(packets, encodeOne, function(err, encodedPackets) {
	    var totalLength = encodedPackets.reduce(function(acc, p) {
	      var len;
	      if (typeof p === 'string'){
	        len = p.length;
	      } else {
	        len = p.byteLength;
	      }
	      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
	    }, 0);

	    var resultArray = new Uint8Array(totalLength);

	    var bufferIndex = 0;
	    encodedPackets.forEach(function(p) {
	      var isString = typeof p === 'string';
	      var ab = p;
	      if (isString) {
	        var view = new Uint8Array(p.length);
	        for (var i = 0; i < p.length; i++) {
	          view[i] = p.charCodeAt(i);
	        }
	        ab = view.buffer;
	      }

	      if (isString) { // not true binary
	        resultArray[bufferIndex++] = 0;
	      } else { // true binary
	        resultArray[bufferIndex++] = 1;
	      }

	      var lenStr = ab.byteLength.toString();
	      for (var i = 0; i < lenStr.length; i++) {
	        resultArray[bufferIndex++] = parseInt(lenStr[i]);
	      }
	      resultArray[bufferIndex++] = 255;

	      var view = new Uint8Array(ab);
	      for (var i = 0; i < view.length; i++) {
	        resultArray[bufferIndex++] = view[i];
	      }
	    });

	    return callback(resultArray.buffer);
	  });
	};

	/**
	 * Encode as Blob
	 */

	exports.encodePayloadAsBlob = function(packets, callback) {
	  function encodeOne(packet, doneCallback) {
	    exports.encodePacket(packet, true, true, function(encoded) {
	      var binaryIdentifier = new Uint8Array(1);
	      binaryIdentifier[0] = 1;
	      if (typeof encoded === 'string') {
	        var view = new Uint8Array(encoded.length);
	        for (var i = 0; i < encoded.length; i++) {
	          view[i] = encoded.charCodeAt(i);
	        }
	        encoded = view.buffer;
	        binaryIdentifier[0] = 0;
	      }

	      var len = (encoded instanceof ArrayBuffer)
	        ? encoded.byteLength
	        : encoded.size;

	      var lenStr = len.toString();
	      var lengthAry = new Uint8Array(lenStr.length + 1);
	      for (var i = 0; i < lenStr.length; i++) {
	        lengthAry[i] = parseInt(lenStr[i]);
	      }
	      lengthAry[lenStr.length] = 255;

	      if (Blob) {
	        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
	        doneCallback(null, blob);
	      }
	    });
	  }

	  map(packets, encodeOne, function(err, results) {
	    return callback(new Blob(results));
	  });
	};

	/*
	 * Decodes data when a payload is maybe expected. Strings are decoded by
	 * interpreting each byte as a key code for entries marked to start with 0. See
	 * description of encodePayloadAsBinary
	 *
	 * @param {ArrayBuffer} data, callback method
	 * @api public
	 */

	exports.decodePayloadAsBinary = function (data, binaryType, callback) {
	  if (typeof binaryType === 'function') {
	    callback = binaryType;
	    binaryType = null;
	  }

	  var bufferTail = data;
	  var buffers = [];

	  while (bufferTail.byteLength > 0) {
	    var tailArray = new Uint8Array(bufferTail);
	    var isString = tailArray[0] === 0;
	    var msgLength = '';

	    for (var i = 1; ; i++) {
	      if (tailArray[i] === 255) break;

	      // 310 = char length of Number.MAX_VALUE
	      if (msgLength.length > 310) {
	        return callback(err, 0, 1);
	      }

	      msgLength += tailArray[i];
	    }

	    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
	    msgLength = parseInt(msgLength);

	    var msg = sliceBuffer(bufferTail, 0, msgLength);
	    if (isString) {
	      try {
	        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
	      } catch (e) {
	        // iPhone Safari doesn't let you apply to typed arrays
	        var typed = new Uint8Array(msg);
	        msg = '';
	        for (var i = 0; i < typed.length; i++) {
	          msg += String.fromCharCode(typed[i]);
	        }
	      }
	    }

	    buffers.push(msg);
	    bufferTail = sliceBuffer(bufferTail, msgLength);
	  }

	  var total = buffers.length;
	  buffers.forEach(function(buffer, i) {
	    callback(exports.decodePacket(buffer, binaryType, true), i, total);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 22 */
/***/ (function(module, exports) {


	/**
	 * Gets the keys for an object.
	 *
	 * @return {Array} keys
	 * @api private
	 */

	module.exports = Object.keys || function keys (obj){
	  var arr = [];
	  var has = Object.prototype.hasOwnProperty;

	  for (var i in obj) {
	    if (has.call(obj, i)) {
	      arr.push(i);
	    }
	  }
	  return arr;
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global Blob File */

	/*
	 * Module requirements.
	 */

	var isArray = __webpack_require__(10);

	var toString = Object.prototype.toString;
	var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
	var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

	/**
	 * Module exports.
	 */

	module.exports = hasBinary;

	/**
	 * Checks for binary data.
	 *
	 * Supports Buffer, ArrayBuffer, Blob and File.
	 *
	 * @param {Object} anything
	 * @api public
	 */

	function hasBinary (obj) {
	  if (!obj || typeof obj !== 'object') {
	    return false;
	  }

	  if (isArray(obj)) {
	    for (var i = 0, l = obj.length; i < l; i++) {
	      if (hasBinary(obj[i])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
	     (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
	     (withNativeBlob && obj instanceof Blob) ||
	     (withNativeFile && obj instanceof File)
	    ) {
	    return true;
	  }

	  // see: https://github.com/Automattic/has-binary/pull/4
	  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
	    return hasBinary(obj.toJSON(), true);
	  }

	  for (var key in obj) {
	    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
	      return true;
	    }
	  }

	  return false;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	/**
	 * An abstraction for slicing an arraybuffer even when
	 * ArrayBuffer.prototype.slice is not supported
	 *
	 * @api public
	 */

	module.exports = function(arraybuffer, start, end) {
	  var bytes = arraybuffer.byteLength;
	  start = start || 0;
	  end = end || bytes;

	  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

	  if (start < 0) { start += bytes; }
	  if (end < 0) { end += bytes; }
	  if (end > bytes) { end = bytes; }

	  if (start >= bytes || start >= end || bytes === 0) {
	    return new ArrayBuffer(0);
	  }

	  var abv = new Uint8Array(arraybuffer);
	  var result = new Uint8Array(end - start);
	  for (var i = start, ii = 0; i < end; i++, ii++) {
	    result[ii] = abv[i];
	  }
	  return result.buffer;
	};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = after

	function after(count, callback, err_cb) {
	    var bail = false
	    err_cb = err_cb || noop
	    proxy.count = count

	    return (count === 0) ? callback() : proxy

	    function proxy(err, result) {
	        if (proxy.count <= 0) {
	            throw new Error('after called too many times')
	        }
	        --proxy.count

	        // after first error, rest are passed to err_cb
	        if (err) {
	            bail = true
	            callback(err)
	            // future error callbacks will go to error handler
	            callback = err_cb
	        } else if (proxy.count === 0 && !bail) {
	            callback(null, result)
	        }
	    }
	}

	function noop() {}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/utf8js v2.1.2 by @mathias */
	;(function(root) {

		// Detect free variables `exports`
		var freeExports = typeof exports == 'object' && exports;

		// Detect free variable `module`
		var freeModule = typeof module == 'object' && module &&
			module.exports == freeExports && module;

		// Detect free variable `global`, from Node.js or Browserified code,
		// and use it as `root`
		var freeGlobal = typeof global == 'object' && global;
		if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
			root = freeGlobal;
		}

		/*--------------------------------------------------------------------------*/

		var stringFromCharCode = String.fromCharCode;

		// Taken from https://mths.be/punycode
		function ucs2decode(string) {
			var output = [];
			var counter = 0;
			var length = string.length;
			var value;
			var extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		// Taken from https://mths.be/punycode
		function ucs2encode(array) {
			var length = array.length;
			var index = -1;
			var value;
			var output = '';
			while (++index < length) {
				value = array[index];
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
			}
			return output;
		}

		function checkScalarValue(codePoint, strict) {
			if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
				if (strict) {
					throw Error(
						'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
						' is not a scalar value'
					);
				}
				return false;
			}
			return true;
		}
		/*--------------------------------------------------------------------------*/

		function createByte(codePoint, shift) {
			return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
		}

		function encodeCodePoint(codePoint, strict) {
			if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
				return stringFromCharCode(codePoint);
			}
			var symbol = '';
			if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
				symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
			}
			else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
				if (!checkScalarValue(codePoint, strict)) {
					codePoint = 0xFFFD;
				}
				symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
				symbol += createByte(codePoint, 6);
			}
			else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
				symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
				symbol += createByte(codePoint, 12);
				symbol += createByte(codePoint, 6);
			}
			symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
			return symbol;
		}

		function utf8encode(string, opts) {
			opts = opts || {};
			var strict = false !== opts.strict;

			var codePoints = ucs2decode(string);
			var length = codePoints.length;
			var index = -1;
			var codePoint;
			var byteString = '';
			while (++index < length) {
				codePoint = codePoints[index];
				byteString += encodeCodePoint(codePoint, strict);
			}
			return byteString;
		}

		/*--------------------------------------------------------------------------*/

		function readContinuationByte() {
			if (byteIndex >= byteCount) {
				throw Error('Invalid byte index');
			}

			var continuationByte = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			if ((continuationByte & 0xC0) == 0x80) {
				return continuationByte & 0x3F;
			}

			// If we end up here, it’s not a continuation byte
			throw Error('Invalid continuation byte');
		}

		function decodeSymbol(strict) {
			var byte1;
			var byte2;
			var byte3;
			var byte4;
			var codePoint;

			if (byteIndex > byteCount) {
				throw Error('Invalid byte index');
			}

			if (byteIndex == byteCount) {
				return false;
			}

			// Read first byte
			byte1 = byteArray[byteIndex] & 0xFF;
			byteIndex++;

			// 1-byte sequence (no continuation bytes)
			if ((byte1 & 0x80) == 0) {
				return byte1;
			}

			// 2-byte sequence
			if ((byte1 & 0xE0) == 0xC0) {
				byte2 = readContinuationByte();
				codePoint = ((byte1 & 0x1F) << 6) | byte2;
				if (codePoint >= 0x80) {
					return codePoint;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 3-byte sequence (may include unpaired surrogates)
			if ((byte1 & 0xF0) == 0xE0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
				if (codePoint >= 0x0800) {
					return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
				} else {
					throw Error('Invalid continuation byte');
				}
			}

			// 4-byte sequence
			if ((byte1 & 0xF8) == 0xF0) {
				byte2 = readContinuationByte();
				byte3 = readContinuationByte();
				byte4 = readContinuationByte();
				codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
					(byte3 << 0x06) | byte4;
				if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
					return codePoint;
				}
			}

			throw Error('Invalid UTF-8 detected');
		}

		var byteArray;
		var byteCount;
		var byteIndex;
		function utf8decode(byteString, opts) {
			opts = opts || {};
			var strict = false !== opts.strict;

			byteArray = ucs2decode(byteString);
			byteCount = byteArray.length;
			byteIndex = 0;
			var codePoints = [];
			var tmp;
			while ((tmp = decodeSymbol(strict)) !== false) {
				codePoints.push(tmp);
			}
			return ucs2encode(codePoints);
		}

		/*--------------------------------------------------------------------------*/

		var utf8 = {
			'version': '2.1.2',
			'encode': utf8encode,
			'decode': utf8decode
		};

		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return utf8;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}	else if (freeExports && !freeExports.nodeType) {
			if (freeModule) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = utf8;
			} else { // in Narwhal or RingoJS v0.7.0-
				var object = {};
				var hasOwnProperty = object.hasOwnProperty;
				for (var key in utf8) {
					hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.utf8 = utf8;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)(module), (function() { return this; }())))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(){
	  "use strict";

	  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	  // Use a lookup table to find the index.
	  var lookup = new Uint8Array(256);
	  for (var i = 0; i < chars.length; i++) {
	    lookup[chars.charCodeAt(i)] = i;
	  }

	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";

	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }

	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }

	    return base64;
	  };

	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;

	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }

	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);

	    for (i = 0; i < len; i+=4) {
	      encoded1 = lookup[base64.charCodeAt(i)];
	      encoded2 = lookup[base64.charCodeAt(i+1)];
	      encoded3 = lookup[base64.charCodeAt(i+2)];
	      encoded4 = lookup[base64.charCodeAt(i+3)];

	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }

	    return arraybuffer;
	  };
	})();


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Create a blob builder even when vendor prefixes exist
	 */

	var BlobBuilder = global.BlobBuilder
	  || global.WebKitBlobBuilder
	  || global.MSBlobBuilder
	  || global.MozBlobBuilder;

	/**
	 * Check if Blob constructor is supported
	 */

	var blobSupported = (function() {
	  try {
	    var a = new Blob(['hi']);
	    return a.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if Blob constructor supports ArrayBufferViews
	 * Fails in Safari 6, so we need to map to ArrayBuffers there.
	 */

	var blobSupportsArrayBufferView = blobSupported && (function() {
	  try {
	    var b = new Blob([new Uint8Array([1,2])]);
	    return b.size === 2;
	  } catch(e) {
	    return false;
	  }
	})();

	/**
	 * Check if BlobBuilder is supported
	 */

	var blobBuilderSupported = BlobBuilder
	  && BlobBuilder.prototype.append
	  && BlobBuilder.prototype.getBlob;

	/**
	 * Helper function that maps ArrayBufferViews to ArrayBuffers
	 * Used by BlobBuilder constructor and old browsers that didn't
	 * support it in the Blob constructor.
	 */

	function mapArrayBufferViews(ary) {
	  for (var i = 0; i < ary.length; i++) {
	    var chunk = ary[i];
	    if (chunk.buffer instanceof ArrayBuffer) {
	      var buf = chunk.buffer;

	      // if this is a subarray, make a copy so we only
	      // include the subarray region from the underlying buffer
	      if (chunk.byteLength !== buf.byteLength) {
	        var copy = new Uint8Array(chunk.byteLength);
	        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
	        buf = copy.buffer;
	      }

	      ary[i] = buf;
	    }
	  }
	}

	function BlobBuilderConstructor(ary, options) {
	  options = options || {};

	  var bb = new BlobBuilder();
	  mapArrayBufferViews(ary);

	  for (var i = 0; i < ary.length; i++) {
	    bb.append(ary[i]);
	  }

	  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
	};

	function BlobConstructor(ary, options) {
	  mapArrayBufferViews(ary);
	  return new Blob(ary, options || {});
	};

	module.exports = (function() {
	  if (blobSupported) {
	    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
	  } else if (blobBuilderSupported) {
	    return BlobBuilderConstructor;
	  } else {
	    return undefined;
	  }
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */

	exports.encode = function (obj) {
	  var str = '';

	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }

	  return str;
	};

	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */

	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ }),
/* 31 */
/***/ (function(module, exports) {


	module.exports = function(a, b){
	  var fn = function(){};
	  fn.prototype = b.prototype;
	  a.prototype = new fn;
	  a.prototype.constructor = a;
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	'use strict';

	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;

	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';

	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);

	  return encoded;
	}

	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;

	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }

	  return decoded;
	}

	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());

	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}

	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;

	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module requirements.
	 */

	var Polling = __webpack_require__(19);
	var inherit = __webpack_require__(31);

	/**
	 * Module exports.
	 */

	module.exports = JSONPPolling;

	/**
	 * Cached regular expressions.
	 */

	var rNewline = /\n/g;
	var rEscapedNewline = /\\n/g;

	/**
	 * Global JSONP callbacks.
	 */

	var callbacks;

	/**
	 * Noop.
	 */

	function empty () { }

	/**
	 * JSONP Polling constructor.
	 *
	 * @param {Object} opts.
	 * @api public
	 */

	function JSONPPolling (opts) {
	  Polling.call(this, opts);

	  this.query = this.query || {};

	  // define global callbacks array if not present
	  // we do this here (lazily) to avoid unneeded global pollution
	  if (!callbacks) {
	    // we need to consider multiple engines in the same page
	    if (!global.___eio) global.___eio = [];
	    callbacks = global.___eio;
	  }

	  // callback identifier
	  this.index = callbacks.length;

	  // add callback to jsonp global
	  var self = this;
	  callbacks.push(function (msg) {
	    self.onData(msg);
	  });

	  // append to query string
	  this.query.j = this.index;

	  // prevent spurious errors from being emitted when the window is unloaded
	  if (global.document && global.addEventListener) {
	    global.addEventListener('beforeunload', function () {
	      if (self.script) self.script.onerror = empty;
	    }, false);
	  }
	}

	/**
	 * Inherits from Polling.
	 */

	inherit(JSONPPolling, Polling);

	/*
	 * JSONP only supports binary as base64 encoded strings
	 */

	JSONPPolling.prototype.supportsBinary = false;

	/**
	 * Closes the socket.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doClose = function () {
	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  if (this.form) {
	    this.form.parentNode.removeChild(this.form);
	    this.form = null;
	    this.iframe = null;
	  }

	  Polling.prototype.doClose.call(this);
	};

	/**
	 * Starts a poll cycle.
	 *
	 * @api private
	 */

	JSONPPolling.prototype.doPoll = function () {
	  var self = this;
	  var script = document.createElement('script');

	  if (this.script) {
	    this.script.parentNode.removeChild(this.script);
	    this.script = null;
	  }

	  script.async = true;
	  script.src = this.uri();
	  script.onerror = function (e) {
	    self.onError('jsonp poll error', e);
	  };

	  var insertAt = document.getElementsByTagName('script')[0];
	  if (insertAt) {
	    insertAt.parentNode.insertBefore(script, insertAt);
	  } else {
	    (document.head || document.body).appendChild(script);
	  }
	  this.script = script;

	  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

	  if (isUAgecko) {
	    setTimeout(function () {
	      var iframe = document.createElement('iframe');
	      document.body.appendChild(iframe);
	      document.body.removeChild(iframe);
	    }, 100);
	  }
	};

	/**
	 * Writes with a hidden iframe.
	 *
	 * @param {String} data to send
	 * @param {Function} called upon flush.
	 * @api private
	 */

	JSONPPolling.prototype.doWrite = function (data, fn) {
	  var self = this;

	  if (!this.form) {
	    var form = document.createElement('form');
	    var area = document.createElement('textarea');
	    var id = this.iframeId = 'eio_iframe_' + this.index;
	    var iframe;

	    form.className = 'socketio';
	    form.style.position = 'absolute';
	    form.style.top = '-1000px';
	    form.style.left = '-1000px';
	    form.target = id;
	    form.method = 'POST';
	    form.setAttribute('accept-charset', 'utf-8');
	    area.name = 'd';
	    form.appendChild(area);
	    document.body.appendChild(form);

	    this.form = form;
	    this.area = area;
	  }

	  this.form.action = this.uri();

	  function complete () {
	    initIframe();
	    fn();
	  }

	  function initIframe () {
	    if (self.iframe) {
	      try {
	        self.form.removeChild(self.iframe);
	      } catch (e) {
	        self.onError('jsonp polling iframe removal error', e);
	      }
	    }

	    try {
	      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	      iframe = document.createElement(html);
	    } catch (e) {
	      iframe = document.createElement('iframe');
	      iframe.name = self.iframeId;
	      iframe.src = 'javascript:0';
	    }

	    iframe.id = self.iframeId;

	    self.form.appendChild(iframe);
	    self.iframe = iframe;
	  }

	  initIframe();

	  // escape \n to prevent it from being converted into \r\n by some UAs
	  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	  data = data.replace(rEscapedNewline, '\\\n');
	  this.area.value = data.replace(rNewline, '\\n');

	  try {
	    this.form.submit();
	  } catch (e) {}

	  if (this.iframe.attachEvent) {
	    this.iframe.onreadystatechange = function () {
	      if (self.iframe.readyState === 'complete') {
	        complete();
	      }
	    };
	  } else {
	    this.iframe.onload = complete;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Module dependencies.
	 */

	var Transport = __webpack_require__(20);
	var parser = __webpack_require__(21);
	var parseqs = __webpack_require__(30);
	var inherit = __webpack_require__(31);
	var yeast = __webpack_require__(32);
	var debug = __webpack_require__(3)('engine.io-client:websocket');
	var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
	var NodeWebSocket;
	if (typeof window === 'undefined') {
	  try {
	    NodeWebSocket = __webpack_require__(35);
	  } catch (e) { }
	}

	/**
	 * Get either the `WebSocket` or `MozWebSocket` globals
	 * in the browser or try to resolve WebSocket-compatible
	 * interface exposed by `ws` for Node-like environment.
	 */

	var WebSocket = BrowserWebSocket;
	if (!WebSocket && typeof window === 'undefined') {
	  WebSocket = NodeWebSocket;
	}

	/**
	 * Module exports.
	 */

	module.exports = WS;

	/**
	 * WebSocket transport constructor.
	 *
	 * @api {Object} connection options
	 * @api public
	 */

	function WS (opts) {
	  var forceBase64 = (opts && opts.forceBase64);
	  if (forceBase64) {
	    this.supportsBinary = false;
	  }
	  this.perMessageDeflate = opts.perMessageDeflate;
	  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
	  this.protocols = opts.protocols;
	  if (!this.usingBrowserWebSocket) {
	    WebSocket = NodeWebSocket;
	  }
	  Transport.call(this, opts);
	}

	/**
	 * Inherits from Transport.
	 */

	inherit(WS, Transport);

	/**
	 * Transport name.
	 *
	 * @api public
	 */

	WS.prototype.name = 'websocket';

	/*
	 * WebSockets support binary
	 */

	WS.prototype.supportsBinary = true;

	/**
	 * Opens socket.
	 *
	 * @api private
	 */

	WS.prototype.doOpen = function () {
	  if (!this.check()) {
	    // let probe timeout
	    return;
	  }

	  var uri = this.uri();
	  var protocols = this.protocols;
	  var opts = {
	    agent: this.agent,
	    perMessageDeflate: this.perMessageDeflate
	  };

	  // SSL options for Node.js client
	  opts.pfx = this.pfx;
	  opts.key = this.key;
	  opts.passphrase = this.passphrase;
	  opts.cert = this.cert;
	  opts.ca = this.ca;
	  opts.ciphers = this.ciphers;
	  opts.rejectUnauthorized = this.rejectUnauthorized;
	  if (this.extraHeaders) {
	    opts.headers = this.extraHeaders;
	  }
	  if (this.localAddress) {
	    opts.localAddress = this.localAddress;
	  }

	  try {
	    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
	  } catch (err) {
	    return this.emit('error', err);
	  }

	  if (this.ws.binaryType === undefined) {
	    this.supportsBinary = false;
	  }

	  if (this.ws.supports && this.ws.supports.binary) {
	    this.supportsBinary = true;
	    this.ws.binaryType = 'nodebuffer';
	  } else {
	    this.ws.binaryType = 'arraybuffer';
	  }

	  this.addEventListeners();
	};

	/**
	 * Adds event listeners to the socket
	 *
	 * @api private
	 */

	WS.prototype.addEventListeners = function () {
	  var self = this;

	  this.ws.onopen = function () {
	    self.onOpen();
	  };
	  this.ws.onclose = function () {
	    self.onClose();
	  };
	  this.ws.onmessage = function (ev) {
	    self.onData(ev.data);
	  };
	  this.ws.onerror = function (e) {
	    self.onError('websocket error', e);
	  };
	};

	/**
	 * Writes data to socket.
	 *
	 * @param {Array} array of packets.
	 * @api private
	 */

	WS.prototype.write = function (packets) {
	  var self = this;
	  this.writable = false;

	  // encodePacket efficient as it uses WS framing
	  // no need for encodePayload
	  var total = packets.length;
	  for (var i = 0, l = total; i < l; i++) {
	    (function (packet) {
	      parser.encodePacket(packet, self.supportsBinary, function (data) {
	        if (!self.usingBrowserWebSocket) {
	          // always create a new object (GH-437)
	          var opts = {};
	          if (packet.options) {
	            opts.compress = packet.options.compress;
	          }

	          if (self.perMessageDeflate) {
	            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
	            if (len < self.perMessageDeflate.threshold) {
	              opts.compress = false;
	            }
	          }
	        }

	        // Sometimes the websocket has already been closed but the browser didn't
	        // have a chance of informing us about it yet, in that case send will
	        // throw an error
	        try {
	          if (self.usingBrowserWebSocket) {
	            // TypeError is thrown when passing the second argument on Safari
	            self.ws.send(data);
	          } else {
	            self.ws.send(data, opts);
	          }
	        } catch (e) {
	          debug('websocket closed before onclose event');
	        }

	        --total || done();
	      });
	    })(packets[i]);
	  }

	  function done () {
	    self.emit('flush');

	    // fake drain
	    // defer to next tick to allow Socket to clear writeBuffer
	    setTimeout(function () {
	      self.writable = true;
	      self.emit('drain');
	    }, 0);
	  }
	};

	/**
	 * Called upon close
	 *
	 * @api private
	 */

	WS.prototype.onClose = function () {
	  Transport.prototype.onClose.call(this);
	};

	/**
	 * Closes socket.
	 *
	 * @api private
	 */

	WS.prototype.doClose = function () {
	  if (typeof this.ws !== 'undefined') {
	    this.ws.close();
	  }
	};

	/**
	 * Generates uri for connection.
	 *
	 * @api private
	 */

	WS.prototype.uri = function () {
	  var query = this.query || {};
	  var schema = this.secure ? 'wss' : 'ws';
	  var port = '';

	  // avoid port if default for schema
	  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
	    ('ws' === schema && Number(this.port) !== 80))) {
	    port = ':' + this.port;
	  }

	  // append timestamp to URI
	  if (this.timestampRequests) {
	    query[this.timestampParam] = yeast();
	  }

	  // communicate binary support capabilities
	  if (!this.supportsBinary) {
	    query.b64 = 1;
	  }

	  query = parseqs.encode(query);

	  // prepend ? to query
	  if (query.length) {
	    query = '?' + query;
	  }

	  var ipv6 = this.hostname.indexOf(':') !== -1;
	  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
	};

	/**
	 * Feature detection for WebSocket.
	 *
	 * @return {Boolean} whether this transport is available.
	 * @api public
	 */

	WS.prototype.check = function () {
	  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 36 */
/***/ (function(module, exports) {


	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Module dependencies.
	 */

	var parser = __webpack_require__(7);
	var Emitter = __webpack_require__(8);
	var toArray = __webpack_require__(38);
	var on = __webpack_require__(39);
	var bind = __webpack_require__(40);
	var debug = __webpack_require__(3)('socket.io-client:socket');
	var parseqs = __webpack_require__(30);
	var hasBin = __webpack_require__(23);

	/**
	 * Module exports.
	 */

	module.exports = exports = Socket;

	/**
	 * Internal events (blacklisted).
	 * These events can't be emitted by the user.
	 *
	 * @api private
	 */

	var events = {
	  connect: 1,
	  connect_error: 1,
	  connect_timeout: 1,
	  connecting: 1,
	  disconnect: 1,
	  error: 1,
	  reconnect: 1,
	  reconnect_attempt: 1,
	  reconnect_failed: 1,
	  reconnect_error: 1,
	  reconnecting: 1,
	  ping: 1,
	  pong: 1
	};

	/**
	 * Shortcut to `Emitter#emit`.
	 */

	var emit = Emitter.prototype.emit;

	/**
	 * `Socket` constructor.
	 *
	 * @api public
	 */

	function Socket(io, nsp, opts) {
	  this.io = io;
	  this.nsp = nsp;
	  this.json = this; // compat
	  this.ids = 0;
	  this.acks = {};
	  this.receiveBuffer = [];
	  this.sendBuffer = [];
	  this.connected = false;
	  this.disconnected = true;
	  this.flags = {};
	  if (opts && opts.query) {
	    this.query = opts.query;
	  }
	  if (this.io.autoConnect) this.open();
	}

	/**
	 * Mix in `Emitter`.
	 */

	Emitter(Socket.prototype);

	/**
	 * Subscribe to open, close and packet events
	 *
	 * @api private
	 */

	Socket.prototype.subEvents = function () {
	  if (this.subs) return;

	  var io = this.io;
	  this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
	};

	/**
	 * "Opens" the socket.
	 *
	 * @api public
	 */

	Socket.prototype.open = Socket.prototype.connect = function () {
	  if (this.connected) return this;

	  this.subEvents();
	  this.io.open(); // ensure open
	  if ('open' === this.io.readyState) this.onopen();
	  this.emit('connecting');
	  return this;
	};

	/**
	 * Sends a `message` event.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.send = function () {
	  var args = toArray(arguments);
	  args.unshift('message');
	  this.emit.apply(this, args);
	  return this;
	};

	/**
	 * Override `emit`.
	 * If the event is in `events`, it's emitted normally.
	 *
	 * @param {String} event name
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.emit = function (ev) {
	  if (events.hasOwnProperty(ev)) {
	    emit.apply(this, arguments);
	    return this;
	  }

	  var args = toArray(arguments);
	  var packet = {
	    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
	    data: args
	  };

	  packet.options = {};
	  packet.options.compress = !this.flags || false !== this.flags.compress;

	  // event ack callback
	  if ('function' === typeof args[args.length - 1]) {
	    debug('emitting packet with ack id %d', this.ids);
	    this.acks[this.ids] = args.pop();
	    packet.id = this.ids++;
	  }

	  if (this.connected) {
	    this.packet(packet);
	  } else {
	    this.sendBuffer.push(packet);
	  }

	  this.flags = {};

	  return this;
	};

	/**
	 * Sends a packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.packet = function (packet) {
	  packet.nsp = this.nsp;
	  this.io.packet(packet);
	};

	/**
	 * Called upon engine `open`.
	 *
	 * @api private
	 */

	Socket.prototype.onopen = function () {
	  debug('transport is open - connecting');

	  // write connect packet if necessary
	  if ('/' !== this.nsp) {
	    if (this.query) {
	      var query = _typeof(this.query) === 'object' ? parseqs.encode(this.query) : this.query;
	      debug('sending connect packet with query %s', query);
	      this.packet({ type: parser.CONNECT, query: query });
	    } else {
	      this.packet({ type: parser.CONNECT });
	    }
	  }
	};

	/**
	 * Called upon engine `close`.
	 *
	 * @param {String} reason
	 * @api private
	 */

	Socket.prototype.onclose = function (reason) {
	  debug('close (%s)', reason);
	  this.connected = false;
	  this.disconnected = true;
	  delete this.id;
	  this.emit('disconnect', reason);
	};

	/**
	 * Called with socket packet.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onpacket = function (packet) {
	  var sameNamespace = packet.nsp === this.nsp;
	  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

	  if (!sameNamespace && !rootNamespaceError) return;

	  switch (packet.type) {
	    case parser.CONNECT:
	      this.onconnect();
	      break;

	    case parser.EVENT:
	      this.onevent(packet);
	      break;

	    case parser.BINARY_EVENT:
	      this.onevent(packet);
	      break;

	    case parser.ACK:
	      this.onack(packet);
	      break;

	    case parser.BINARY_ACK:
	      this.onack(packet);
	      break;

	    case parser.DISCONNECT:
	      this.ondisconnect();
	      break;

	    case parser.ERROR:
	      this.emit('error', packet.data);
	      break;
	  }
	};

	/**
	 * Called upon a server event.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onevent = function (packet) {
	  var args = packet.data || [];
	  debug('emitting event %j', args);

	  if (null != packet.id) {
	    debug('attaching ack callback to event');
	    args.push(this.ack(packet.id));
	  }

	  if (this.connected) {
	    emit.apply(this, args);
	  } else {
	    this.receiveBuffer.push(args);
	  }
	};

	/**
	 * Produces an ack callback to emit with an event.
	 *
	 * @api private
	 */

	Socket.prototype.ack = function (id) {
	  var self = this;
	  var sent = false;
	  return function () {
	    // prevent double callbacks
	    if (sent) return;
	    sent = true;
	    var args = toArray(arguments);
	    debug('sending ack %j', args);

	    self.packet({
	      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
	      id: id,
	      data: args
	    });
	  };
	};

	/**
	 * Called upon a server acknowlegement.
	 *
	 * @param {Object} packet
	 * @api private
	 */

	Socket.prototype.onack = function (packet) {
	  var ack = this.acks[packet.id];
	  if ('function' === typeof ack) {
	    debug('calling ack %s with %j', packet.id, packet.data);
	    ack.apply(this, packet.data);
	    delete this.acks[packet.id];
	  } else {
	    debug('bad ack %s', packet.id);
	  }
	};

	/**
	 * Called upon server connect.
	 *
	 * @api private
	 */

	Socket.prototype.onconnect = function () {
	  this.connected = true;
	  this.disconnected = false;
	  this.emit('connect');
	  this.emitBuffered();
	};

	/**
	 * Emit buffered events (received and emitted).
	 *
	 * @api private
	 */

	Socket.prototype.emitBuffered = function () {
	  var i;
	  for (i = 0; i < this.receiveBuffer.length; i++) {
	    emit.apply(this, this.receiveBuffer[i]);
	  }
	  this.receiveBuffer = [];

	  for (i = 0; i < this.sendBuffer.length; i++) {
	    this.packet(this.sendBuffer[i]);
	  }
	  this.sendBuffer = [];
	};

	/**
	 * Called upon server disconnect.
	 *
	 * @api private
	 */

	Socket.prototype.ondisconnect = function () {
	  debug('server disconnect (%s)', this.nsp);
	  this.destroy();
	  this.onclose('io server disconnect');
	};

	/**
	 * Called upon forced client/server side disconnections,
	 * this method ensures the manager stops tracking us and
	 * that reconnections don't get triggered for this.
	 *
	 * @api private.
	 */

	Socket.prototype.destroy = function () {
	  if (this.subs) {
	    // clean subscriptions to avoid reconnections
	    for (var i = 0; i < this.subs.length; i++) {
	      this.subs[i].destroy();
	    }
	    this.subs = null;
	  }

	  this.io.destroy(this);
	};

	/**
	 * Disconnects the socket manually.
	 *
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.close = Socket.prototype.disconnect = function () {
	  if (this.connected) {
	    debug('performing disconnect (%s)', this.nsp);
	    this.packet({ type: parser.DISCONNECT });
	  }

	  // remove socket from pool
	  this.destroy();

	  if (this.connected) {
	    // fire events
	    this.onclose('io client disconnect');
	  }
	  return this;
	};

	/**
	 * Sets the compress flag.
	 *
	 * @param {Boolean} if `true`, compresses the sending data
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.compress = function (compress) {
	  this.flags.compress = compress;
	  return this;
	};

	/**
	 * Sets the binary flag
	 *
	 * @param {Boolean} whether the emitted data contains binary
	 * @return {Socket} self
	 * @api public
	 */

	Socket.prototype.binary = function (binary) {
	  this.flags.binary = binary;
	  return this;
	};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	module.exports = toArray

	function toArray(list, index) {
	    var array = []

	    index = index || 0

	    for (var i = index || 0; i < list.length; i++) {
	        array[i - index] = list[i]
	    }

	    return array
	}


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Module exports.
	 */

	module.exports = on;

	/**
	 * Helper for subscriptions.
	 *
	 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
	 * @param {String} event name
	 * @param {Function} callback
	 * @api public
	 */

	function on(obj, ev, fn) {
	  obj.on(ev, fn);
	  return {
	    destroy: function destroy() {
	      obj.removeListener(ev, fn);
	    }
	  };
	}

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Bind `obj` to `fn`.
	 *
	 * @param {Object} obj
	 * @param {Function|String} fn or string
	 * @return {Function}
	 * @api public
	 */

	module.exports = function(obj, fn){
	  if ('string' == typeof fn) fn = obj[fn];
	  if ('function' != typeof fn) throw new Error('bind() requires a function');
	  var args = slice.call(arguments, 2);
	  return function(){
	    return fn.apply(obj, args.concat(slice.call(arguments)));
	  }
	};


/***/ }),
/* 41 */
/***/ (function(module, exports) {


	/**
	 * Expose `Backoff`.
	 */

	module.exports = Backoff;

	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */

	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}

	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */

	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};

	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */

	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};

	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};

	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */

	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};

	/**
	 * Set the jitter
	 *
	 * @api public
	 */

	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};



/***/ })
/******/ ])
});
;


// WEBPACK FOOTER //
// socket.io.js",
" 	// The module cache
 	var installedModules = {};

 	// The require function
 	function __webpack_require__(moduleId) {

 		// Check if module is in cache
 		if(installedModules[moduleId])
 			return installedModules[moduleId].exports;

 		// Create a new module (and put it into the cache)
 		var module = installedModules[moduleId] = {
 			exports: {},
 			id: moduleId,
 			loaded: false
 		};

 		// Execute the module function
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

 		// Flag the module as loaded
 		module.loaded = true;

 		// Return the exports of the module
 		return module.exports;
 	}


 	// expose the modules object (__webpack_modules__)
 	__webpack_require__.m = modules;

 	// expose the module cache
 	__webpack_require__.c = installedModules;

 	// __webpack_public_path__
 	__webpack_require__.p = "";

 	// Load entry module and return exports
 	return __webpack_require__(0);



// WEBPACK FOOTER //
// webpack/bootstrap 3dcdaa84a447b9ebdc0b",
"
/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');



// WEBPACK FOOTER //
// ./lib/index.js",
"
/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}



// WEBPACK FOOTER //
// ./lib/url.js",
"/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};



//////////////////
// WEBPACK FOOTER
// ./~/parseuri/index.js
// module id = 2
// module chunks = 0",
"/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}



//////////////////
// WEBPACK FOOTER
// ./~/debug/src/browser.js
// module id = 3
// module chunks = 0",
"// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };



//////////////////
// WEBPACK FOOTER
// ./~/process/browser.js
// module id = 4
// module chunks = 0",
"
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}



//////////////////
// WEBPACK FOOTER
// ./~/debug/src/debug.js
// module id = 5
// module chunks = 0",
"/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}



//////////////////
// WEBPACK FOOTER
// ./~/ms/index.js
// module id = 6
// module chunks = 0",
"
/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}



//////////////////
// WEBPACK FOOTER
// ./~/socket.io-parser/index.js
// module id = 7
// module chunks = 0",
"
/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};



//////////////////
// WEBPACK FOOTER
// ./~/component-emitter/index.js
// module id = 8
// module chunks = 0",
"/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');
var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};



//////////////////
// WEBPACK FOOTER
// ./~/socket.io-parser/binary.js
// module id = 9
// module chunks = 0",
"var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};



//////////////////
// WEBPACK FOOTER
// ./~/isarray/index.js
// module id = 10
// module chunks = 0",
"
module.exports = isBuf;

var withNativeBuffer = typeof global.Buffer === 'function' && typeof global.Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof global.ArrayBuffer === 'function';

var isView = (function () {
  if (withNativeArrayBuffer && typeof global.ArrayBuffer.isView === 'function') {
    return global.ArrayBuffer.isView;
  } else {
    return function (obj) { return obj.buffer instanceof global.ArrayBuffer; };
  }
})();

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && global.Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof global.ArrayBuffer || isView(obj)));
}



//////////////////
// WEBPACK FOOTER
// ./~/socket.io-parser/is-buffer.js
// module id = 11
// module chunks = 0",
"
/**
 * Module dependencies.
 */

var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};



// WEBPACK FOOTER //
// ./lib/manager.js",
"
module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/index.js
// module id = 13
// module chunks = 0",
"/**
 * Module dependencies.
 */

var transports = require('./transports/index');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports/index');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0)
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/socket.js
// module id = 14
// module chunks = 0",
"/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/transports/index.js
// module id = 15
// module chunks = 0",
"// browser shim for xmlhttprequest module

var hasCORS = require('has-cors');

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/xmlhttprequest.js
// module id = 16
// module chunks = 0",
"
/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}



//////////////////
// WEBPACK FOOTER
// ./~/has-cors/index.js
// module id = 17
// module chunks = 0",
"/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest-ssl');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/transports/polling-xhr.js
// module id = 18
// module chunks = 0",
"/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = require('xmlhttprequest-ssl');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/transports/polling.js
// module id = 19
// module chunks = 0",
"/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/transport.js
// module id = 20
// module chunks = 0",
"/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary2');
var sliceBuffer = require('arraybuffer.slice');
var after = require('after');
var utf8 = require('./utf8');

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = require('base64-arraybuffer');
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-parser/lib/browser.js
// module id = 21
// module chunks = 0",
"
/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-parser/lib/keys.js
// module id = 22
// module chunks = 0",
"/* global Blob File */

/*
 * Module requirements.
 */

var isArray = require('isarray');

var toString = Object.prototype.toString;
var withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';
var withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
     (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
     (withNativeBlob && obj instanceof Blob) ||
     (withNativeFile && obj instanceof File)
    ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}



//////////////////
// WEBPACK FOOTER
// ./~/has-binary2/index.js
// module id = 23
// module chunks = 0",
"/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};



//////////////////
// WEBPACK FOOTER
// ./~/arraybuffer.slice/index.js
// module id = 24
// module chunks = 0",
"module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}



//////////////////
// WEBPACK FOOTER
// ./~/after/index.js
// module id = 25
// module chunks = 0",
"/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint, strict) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			if (strict) {
				throw Error(
					'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
					' is not a scalar value'
				);
			}
			return false;
		}
		return true;
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint, strict) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			if (!checkScalarValue(codePoint, strict)) {
				codePoint = 0xFFFD;
			}
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint, strict);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol(strict) {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString, opts) {
		opts = opts || {};
		var strict = false !== opts.strict;

		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol(strict)) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-parser/lib/utf8.js
// module id = 26
// module chunks = 0",
"module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		module.children = [];
		module.webpackPolyfill = 1;
	}
	return module;
}



//////////////////
// WEBPACK FOOTER
// (webpack)/buildin/module.js
// module id = 27
// module chunks = 0",
"/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();



//////////////////
// WEBPACK FOOTER
// ./~/base64-arraybuffer/lib/base64-arraybuffer.js
// module id = 28
// module chunks = 0",
"/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();



//////////////////
// WEBPACK FOOTER
// ./~/blob/index.js
// module id = 29
// module chunks = 0",
"/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};



//////////////////
// WEBPACK FOOTER
// ./~/parseqs/index.js
// module id = 30
// module chunks = 0",
"
module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};


//////////////////
// WEBPACK FOOTER
// ./~/component-inherit/index.js
// module id = 31
// module chunks = 0",
"'use strict';

var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;



//////////////////
// WEBPACK FOOTER
// ./~/yeast/index.js
// module id = 32
// module chunks = 0",
"
/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/transports/polling-jsonp.js
// module id = 33
// module chunks = 0",
"/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var yeast = require('yeast');
var debug = require('debug')('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = require('ws');
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};



//////////////////
// WEBPACK FOOTER
// ./~/engine.io-client/lib/transports/websocket.js
// module id = 34
// module chunks = 0",
"
var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};


//////////////////
// WEBPACK FOOTER
// ./~/indexof/index.js
// module id = 36
// module chunks = 0",
"
/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var parseqs = require('parseqs');
var hasBin = require('has-binary2');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};



// WEBPACK FOOTER //
// ./lib/socket.js",
"module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}



//////////////////
// WEBPACK FOOTER
// ./~/to-array/index.js
// module id = 38
// module chunks = 0",
"
/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}



// WEBPACK FOOTER //
// ./lib/on.js",
"/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};



//////////////////
// WEBPACK FOOTER
// ./~/component-bind/index.js
// module id = 40
// module chunks = 0",
"
/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};




//////////////////
// WEBPACK FOOTER
// ./~/backo2/index.js
// module id = 41
// module chunks = 0",
],
sourceRoot: "",
}
+-View sourceoptions
